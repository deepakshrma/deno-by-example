{"searchDocs":[{"title":"Greet From CLI","type":0,"sectionRef":"#","url":"/deno-by-example/02-greet-from-cli","content":"","keywords":"beginner helloworld CLI","version":"Next"},{"title":"Take user input as command line arguments‚Äã","type":1,"pageTitle":"Greet From CLI","url":"/deno-by-example/02-greet-from-cli#take-user-input-as-command-line-arguments","content":" Create file examples/02_greet_from_cli.ts  const { args } = Deno; interface UserInput { name?: string; } function main({ name }: UserInput) { console.log(`Hello ${name ? name : &quot;world&quot;}`); } main({ name: args[0] });   Run Using deno run by passing name  $ deno run examples/02_greet_from_cli.ts Deepak #[Output] Hello Deepak $ deno run examples/02_greet_from_cli.ts #[Output] Hello World  ","version":"Next","tagName":"h2"},{"title":"Numbers","type":0,"sectionRef":"#","url":"/deno-by-example/03-numbers","content":"Numbers Since deno is supporting Typescript which is super-set of the JavaScript. It support all the syntax from the JavaScript. However, Deno is a more then that. It also support APIs for file reading and network and etc. Here below are some examples, that explains how numbers behave in Deno[Javascript]. There are some Gotcha in Number as it is in JavaScript. Sample: function main() { const num = 10; const num2: number = 20; // same as above but declarative let num3: number; num3 = num + num2; console.log(num3); // num3 = num + &quot;20&quot; // Error, Type 'string' is not assignable to type 'number' num3 = num + Number(&quot;20&quot;); // No error, cast string to number console.log(num3); num3 = num + parseInt(&quot;20&quot;, 10); // same as above console.log(num3); let flt = 10.0; console.log(flt === 10); // true console.log(flt === 10.1); // false console.log(typeof flt, typeof 10); //number number console.log(typeof NaN, typeof Infinity, typeof -Infinity); // number number number console.log(NaN === NaN); // false console.log(1.2 + 1.8); // 3 NOT 3.0 console.log(1.2 + 1.8 === 3); // true } main(); Things to be noted as in JS, deno also has same number for int and float number. NaN, Infinity are some special NaN. More: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number How to run example: deno run examples/03_numbers.ts ","keywords":"beginner number javascript gotcha","version":"Next"},{"title":"Variables and Constants","type":0,"sectionRef":"#","url":"/deno-by-example/05-variables-constants","content":"Variables and Constants Constant can be created using const and variable can be created using let. Sample: function main() { const constant = 10; // constant = 12 // Error, Cannot assign to 'constant' because it is a constant. console.log(constant); const object = { name: &quot;deepak&quot;, }; object.name = &quot;updated&quot;; // No Error in updating property // object = {} // Error, Cannot assign to 'object' because it is a constant. // Cant change reference // Same for Array const array = [10, 12]; array[0] = 12; // array = [] // Error // Cant change reference let variable = 10; variable = 12; // No issue let arrVar = [12]; arrVar = []; } main(); More: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const How to run example: deno run examples/05_variables_constants.ts ","keywords":"beginner variables constants","version":"Next"},{"title":"Hello World","type":0,"sectionRef":"#","url":"/deno-by-example/01-hello-world","content":"","keywords":"beginner helloworld server","version":"Next"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Hello World","url":"/deno-by-example/01-hello-world#introduction","content":" Deno is design to keeping web in mind. As Deno team mentioned. Deno is to  Provide Secure DefaultsBrowser compatibleBe able to serve HTTP efficiently    Deno provide standard package std/http for working with http/https server. This includes an HTTP client and an HTTP server. In this example i will show how simple it is, to create a webserver.  ","version":"Next","tagName":"h2"},{"title":"Import serve from http module‚Äã","type":1,"pageTitle":"Hello World","url":"/deno-by-example/01-hello-world#import-serve-from-http-module","content":" import { serve } from &quot;https://deno.land/std/http/server.ts&quot;;   ","version":"Next","tagName":"h3"},{"title":"Create a server instance to listen on port 8080‚Äã","type":1,"pageTitle":"Hello World","url":"/deno-by-example/01-hello-world#create-a-server-instance-to-listen-on-port-8080","content":" import { serve } from &quot;https://deno.land/std/http/server.ts&quot;; const server = serve({ port: 8080 });   ","version":"Next","tagName":"h3"},{"title":"Create request handler‚Äã","type":1,"pageTitle":"Hello World","url":"/deno-by-example/01-hello-world#create-request-handler","content":" examples/01_hello_world.ts import { serve } from &quot;https://deno.land/std/http/server.ts&quot;; const PORT = 8080; const server = serve({ port: PORT }); console.log(`Your server is running on http://localhost:${PORT}/`); for await (const req of server) { req.respond({ body: &quot;Hello World\\n&quot; }); }   Run App:  denorun examples/01_hello_world.ts #OR deno run --allow-net --allow-read examples/01_hello_world.ts   note In my first command i am using denorun. It is alias, created for dev environment. If you have't read my get started tutorial, I will recommend you to read it getting-started  Open browser at http://localhost:8080/. You will see hello world.  Breakdown:  When you create an instance of serve. It return an async generator server. We can wait forever client to connect using for-await loop. And respond to client using req.respond method. respond expects Response object.  for await (const req of server)  You can read more about async generator here.  allow-net As mentioned earlier, Deno is build for security. By default network access is not allowed. You need to pass --allow-net as argument.  ","version":"Next","tagName":"h3"},{"title":"Respond a JSON‚Äã","type":1,"pageTitle":"Hello World","url":"/deno-by-example/01-hello-world#respond-a-json","content":" When you respond a request, by default no header is assign to response. You need to set header to response a JSON object. Let's see in example.  examples/01_hello_world.ts import { serve, Response } from &quot;https://deno.land/std/http/server.ts&quot;; const PORT = 8080; const server = serve({ port: PORT }); for await (const req of server) { const response: Response = {}; // Create a Response instance, init with {} response.headers = new Headers(); // Create Headers object and assign to response response.headers.set(&quot;content-type&quot;, &quot;application/json&quot;); // set header as json const body = { message: &quot;hello world&quot; }; // Create response body response.body = JSON.stringify(body); // Serialize to string bytes. req.respond(response); // respond response }   Run App:  denorun examples/01_hello_world.ts #OR deno run --allow-net --allow-read examples/01_hello_world.ts   Open browser at http://localhost:8080/. You will see {&quot;message&quot;:&quot;hello world&quot;}.  Breakdown:The Response interface look like as below.  export interface Response { status?: number; headers?: Headers; body?: Uint8Array | Reader | string; trailers?: () =&gt; Promise&lt;Headers&gt; | Headers; }   body can only accept Uint8Array | Reader | string. So we need to serialize the object to jSON string.  Read More: You can go to https://deno.land/std/http to read more about http module  Examples: You can find all example at https://github.com/deepakshrma/deno-by-example/blob/master/examples/ ","version":"Next","tagName":"h3"},{"title":"Deno By Example","type":0,"sectionRef":"#","url":"/deno-by-example/introduction","content":"","keywords":"","version":"Next"},{"title":"This website to show examples on the Deno language. Examples are written in md files in docs directories‚Äã","type":1,"pageTitle":"Deno By Example","url":"/deno-by-example/introduction#this-website-to-show-examples-on-the-deno-language-examples-are-written-in-md-files-in-docs-directories","content":" -- Github https://github.com/deepakshrma/deno-by-example/tree/master/examples.  Please support me creating more examples.  Thanks! Cheers! ü•Çüçªüçª Keep coding!! ","version":"Next","tagName":"h3"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/deno-by-example/getting-started","content":"","keywords":"beginner started deno","version":"Next"},{"title":"Download and install‚Äã","type":1,"pageTitle":"Getting Started","url":"/deno-by-example/getting-started#download-and-install","content":" Using Shell (macOS and Linux):  curl -fsSL https://deno.land/x/install/install.sh | sh   Using Homebrew (macOS):  brew install deno   More: https://deno.land/manual/getting_started/installation  ","version":"Next","tagName":"h2"},{"title":"Setup your environment‚Äã","type":1,"pageTitle":"Getting Started","url":"/deno-by-example/getting-started#setup-your-environment","content":" VS CODE:  The beta version of vscode_deno is published on the Visual Studio Marketplace. Please report any issues.  Using command line interface:  code --install-extension denoland.vscode-deno   More: https://deno.land/manual/getting_started/setup_your_environment  ","version":"Next","tagName":"h2"},{"title":"Create Alias for deno run‚Äã","type":1,"pageTitle":"Getting Started","url":"/deno-by-example/getting-started#create-alias-for-deno-run","content":" ~/.bash_profile alias denorun=&quot;deno run -A&quot;   This will help and ease the running application in local.  AVOID IN PROD Please don't use in actual enviroment.  ","version":"Next","tagName":"h3"},{"title":"Hello World Program‚Äã","type":1,"pageTitle":"Getting Started","url":"/deno-by-example/getting-started#hello-world-program","content":" examples/01_hello_world.ts function main() { console.log(`Hello &quot;world&quot;`); } main();   How to run example:  denorun examples/01_hello_world.ts ## OR deno run examples/01_hello_world.ts  ","version":"Next","tagName":"h3"},{"title":"Implementing JQ equivalent in Deno","type":0,"sectionRef":"#","url":"/deno-by-example/advanced-jq","content":"","keywords":"advanced JQ grep JSON parser","version":"Next"},{"title":"How to create a stdin‚Äã","type":1,"pageTitle":"Implementing JQ equivalent in Deno","url":"/deno-by-example/advanced-jq#how-to-create-a-stdin","content":" Passing data as stdin is very easy. You can use &lt; to pipe data to any program.  Example:  deno run program.ts &lt; file_name.txt deno run programe.ts &lt; echo &quot;data here&quot;   You can also pass the output of any program to the other program using pipe(|).Example:  cat file_name.txt | deno run program.ts echo &quot;data here&quot; | deno run programe.ts   ","version":"Next","tagName":"h2"},{"title":"How to read stdin in Deno.‚Äã","type":1,"pageTitle":"Implementing JQ equivalent in Deno","url":"/deno-by-example/advanced-jq#how-to-read-stdin-in-deno","content":" Reading stdin is very similar to reding and stream in Deno. Deno provides core API like Deno.read and Deno.readAll  // examples/advance_jq.ts const stdinContent = await Deno.readAll(Deno.stdin); console.log(stdinContent);   Run:  deno run examples/advance_jq.ts &lt; examples/advance_jq.ts   When you run this program, This will print some numbers (Uint8Array). Like other languages, stream data is buffer data encoded in buffer. To convert we need TextDecoder.  // examples/advance_jq.ts const stdinContent = await Deno.readAll(Deno.stdin); const response = new TextDecoder().decode(stdinContent); console.log(response);   Run:  deno run examples/advance_jq.ts &lt; examples/advance_jq.ts   You can see you file data as output  ","version":"Next","tagName":"h2"},{"title":"Parsing JSON‚Äã","type":1,"pageTitle":"Implementing JQ equivalent in Deno","url":"/deno-by-example/advanced-jq#parsing-json","content":" Parsing JSON and extracting value is a very tedious task. I have written a basic Extract value from an object based on key provided. Code look as below:  const evalReg = /(\\.)|(\\[(\\d)\\])/; const safeEval = (key: string, obj: any) =&gt; { let lastKey; let match; do { if (lastKey) { if (match &amp;&amp; match[2]) { obj = obj[lastKey][match[3]]; } else { obj = obj[lastKey]; } } match = evalReg.exec(key); if (!match) { lastKey = key; break; } else { lastKey = key.substr(0, match.index); key = key.slice(!match[3] ? match.index + 1 : match.index + 3); } } while (match); if (lastKey) { obj = obj[lastKey]; } return obj; };   Here i am using RegExp.execmore method to parse the key and extract tokens. This is a very rough sample of what JQ can do. So safeEvel code is also small üòÅ.  How this method works:  const obj = { id: 1, version: &quot;1.0.1&quot;, contributors: [&quot;deepak&quot;, &quot;gary&quot;], actor: { name: &quot;Tom Cruise&quot;, age: 56, &quot;Born At&quot;: &quot;Syracuse, NY&quot;, Birthdate: &quot;July 3 1962&quot;, movies: [&quot;Top Gun&quot;, &quot;Mission: Impossible&quot;, &quot;Oblivion&quot;], photo: &quot;https://jsonformatter.org/img/tom-cruise.jpg&quot;, }, }; console.log(JSON.stringify(obj, null, 2)); console.log(safeEval(&quot;id&quot;, obj)); console.log(safeEval(&quot;contributors&quot;, obj)); console.log(safeEval(&quot;contributors[1]&quot;, obj)); console.log(safeEval(&quot;actor.movies[2]&quot;, obj));   OUTPUT:  1 [ &quot;deepak&quot;, &quot;gary&quot; ] gary Oblivion   As you can see, this is very much what we need. Let's complete the actual demo.  [Note:] Thanks to Deno import, now i can use this file from github directly. I don't need to create another file to import. You can do that. However, I will use network to import.  import safeEval from &quot;https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/examples/safe_eval.ts&quot;; const stdinContent = await Deno.readAll(Deno.stdin); const response = new TextDecoder().decode(stdinContent); try { console.log(safeEval(key, JSON.parse(response))); } catch (err) { console.log(response); }   But wait, from where we will get missing key ??    (c) Photo by Paolo Nicolello on Unsplash  Deno provides direct access to arguments passed to programs using CLI. We can use Deno.args to get all the arguments passed to programs as an Array. Let's use it.  import safeEval from &quot;https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/examples/safe_eval.ts&quot;; const stdinContent = await Deno.readAll(Deno.stdin); const response = new TextDecoder().decode(stdinContent); const [key = &quot;&quot;] = Deno.args; try { console.log(safeEval(key, JSON.parse(response))); } catch (err) { console.log(response); }   You can create a json(tom.json) and tryout.  /* tom.json */ { &quot;id&quot;: 1, &quot;version&quot;: &quot;1.0.1&quot;, &quot;contributors&quot;: [&quot;deepak&quot;, &quot;gary&quot;], &quot;actor&quot;: { &quot;name&quot;: &quot;Tom Cruise&quot;, &quot;age&quot;: 56, &quot;Born At&quot;: &quot;Syracuse, NY&quot;, &quot;Birthdate&quot;: &quot;July 3 1962&quot;, &quot;movies&quot;: [&quot;Top Gun&quot;, &quot;Mission: Impossible&quot;, &quot;Oblivion&quot;], &quot;photo&quot;: &quot;https://jsonformatter.org/img/tom-cruise.jpg&quot; } }   Run:  $ deno run examples/advance_jq.ts &quot;id&quot; &lt; examples/tom.json ## 1 $ deno run examples/advance_jq.ts &quot;actor.name&quot; &lt; examples/tom.json ## Tom Cruise   Perfect: Let's try with curl  curl -s -k https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/examples/tom.json | deno run examples/advance_jq.ts &quot;actor.movies[1]&quot;   Output: Mission: Impossible  Nice! Mission: I am possible  I hope you like this tutorial. let me know your feedback in the comment. Please support(üôèüôè) by subscribing and clapping on https://deepak-v.medium.com/.  Read More: Deno.readAll ","version":"Next","tagName":"h2"},{"title":"Run Deno Application on docker | Continuous Integration and Deployment","type":0,"sectionRef":"#","url":"/deno-by-example/advanced-run-on-docker","content":"","keywords":"advanced docker data cicd tools devops","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"Run Deno Application on docker | Continuous Integration and Deployment","url":"/deno-by-example/advanced-run-on-docker#overview","content":" Before starting code, Lets understand the concept of CICD in brief. This will give us motive to read this blog further.  By- ThoughtWorks‚Äô definition for CI  Continuous Integration (CI) is a development practice that requires developers to integrate code into a shared repository several times a day. Each check-in is then verified by an automated build, allowing teams to detect problems early.   Read more: https://www.thoughtworks.com/es/continuous-integration  By- Jez Humble‚Äôs site  Continuous Delivery is the ability to get changes of all types‚Äîincluding new features, configuration changes, bug fixes and experiments‚Äîinto production, or into the hands of users, safely and quickly in a sustainable way.   Read more: https://continuousdelivery.com/  As we can see, There are many reason why we should follow the CICD in our project development cycle. The one of reason why i follow CICD in daily work. Its ease my work and I get a consistant environment for my development work. So that i can focus on more good things rather than debuging Binary breaking issue.  If you want to read more on CICD, You can read this article.    In this tutorial, I will mainly focus on how you can setup Simple Deno Web Application just using some docker commands. In next tuitor, I will explain how to setup a FullStack Deno Application.  ","version":"Next","tagName":"h2"},{"title":"1. Create a simple Deno WebApp‚Äã","type":1,"pageTitle":"Run Deno Application on docker | Continuous Integration and Deployment","url":"/deno-by-example/advanced-run-on-docker#1-create-a-simple-deno-webapp","content":" To show working example, We need to create a sample Application. Since the focus of this tutorial is not to create WebApp. I will recoomend you to checkout my tutorial here or medium.  The given app is a SSR app, has only some basic functionality. You can checkout source in /examples/ssr folder. Once you run app, Open http://localhost:8000/ on browser. You will see Web as given below.    cd examples/ssr deno run --allow-net --allow-read --unstable server.tsx -c tsconfig.json   ","version":"Next","tagName":"h2"},{"title":"2. Create a Dockerfile‚Äã","type":1,"pageTitle":"Run Deno Application on docker | Continuous Integration and Deployment","url":"/deno-by-example/advanced-run-on-docker#2-create-a-dockerfile","content":" App looks good! Let's now create a Dockerfile to startwith.  md docker-app &amp;&amp; touch Dockerfile   To test our docker is working fine, Let's add some Hello World program.  Dockerfile FROM alpine RUN echo &quot;Hello Stanger!&quot;   Build and Run:  docker build -t chucknorris . docker run -it chucknorris   Explaination: Here in above Dockerfile, First We are pulling the lightest linux base OS. Once pull done, We are trying to Run echo command. If all good, you will see below output.   ---&gt; Running in 5215187d3d6a Hello Stanger! Removing intermediate container 5215187d3d6a   The above output tell us, things are OK.  ","version":"Next","tagName":"h2"},{"title":"3. Install Deno Using docker‚Äã","type":1,"pageTitle":"Run Deno Application on docker | Continuous Integration and Deployment","url":"/deno-by-example/advanced-run-on-docker#3-install-deno-using-docker","content":" By default, Alpine image does not have any external software. This is the one of the thinest Linux client. To install Deno, We need to curl Deno binary. You can read all the details on Deno WebSite.  Let's add curl using Dockerfile.  Dockerfile FROM alpine RUN apk update &amp;&amp; apk add curl ENTRYPOINT [&quot;curl&quot;] CMD [ &quot;curl&quot;, &quot;https://api.chucknorris.io/jokes/random&quot; ]   Build and Run:  docker build -t chucknorris . docker run -it chucknorris   Once you run you will see output along with chucknorris joke. I got mine joke as &quot;Chuck Norris once threw a 'block party'. The city of Detroit filed for bankruptcy the next day&quot;. If your are lucky, You may get more funnier joke.  Download Deno Binary:Now time to install/download pre-compile version of Deno binary  Dockerfile FROM alpine RUN apk update &amp;&amp; apk add curl RUN curl -fsSL https://deno.land/x/install/install.sh | sh &amp;&amp; mv /root/.deno/bin/deno /bin/deno ENTRYPOINT [&quot;dono&quot;] CMD [&quot;run&quot;, &quot;--allow-net&quot;, &quot;https://deno.land/std/examples/welcome.ts&quot;]   Build and Run:  docker build -t deno-app . docker run -it deno-app   Issue There are some compiled libraries missing on Alpine image. So when you try to run Deno you may can see error like standard_init_linux.go:211: exec user process caused. To fix above error, We will you modified version of Alpine Image.  Let's update our docker file.  Dockerfile FROM frolvlad/alpine-glibc:alpine-3.11_glibc-2.31 RUN apk update &amp;&amp; apk add curl RUN curl -fsSL https://deno.land/x/install/install.sh | sh &amp;&amp; mv /root/.deno/bin/deno /bin/deno ENTRYPOINT [&quot;deno&quot;] CMD [&quot;run&quot;, &quot;--allow-net&quot;, &quot;https://deno.land/std/examples/welcome.ts&quot;]   Explaination: Once we pulled the image, We used curl to get the installation script from Deno website and download Deno binary. Since default path of deno binary is not bin. So we need to copy binary to bin. You can find better way to setup path.ENTRYPOINT is to tell docker what command to use when we run docker run command. CMD is the command to run.  If all OK, you will see bellow output.  ‚ùØ docker run -it deno-app Download https://deno.land/std/examples/welcome.ts Warning Implicitly using latest version (0.64.0) for https://deno.land/std/examples/welcome.ts Download https://deno.land/std@0.64.0/examples/welcome.ts Check https://deno.land/std@0.64.0/examples/welcome.ts Welcome to Deno ü¶ï   ","version":"Next","tagName":"h2"},{"title":"4. Running Todo App‚Äã","type":1,"pageTitle":"Run Deno Application on docker | Continuous Integration and Deployment","url":"/deno-by-example/advanced-run-on-docker#4-running-todo-app","content":" We have completed our 90% job. Let's run our todo-app. For that, we need to copy all the required files to the docker image. We can do either using COPY command or mount volume. I will show both way of doing it. However, recoomended is to use COPY. This is to decouple your sytem from Docker.  Using COPY:  Forbidden path outside the build context Since docker does not allow file to be coppied from out of the foder. We have to copy files from /examples/ssr folder to examples/docker-app.  pwd #something/examples/docker-app cp -r ../ssr ./ssr   Update Dockerfile to copy files.  Dockerfile FROM frolvlad/alpine-glibc:alpine-3.11_glibc-2.31 RUN apk update &amp;&amp; apk add curl RUN curl -fsSL https://deno.land/x/install/install.sh | sh &amp;&amp; mv /root/.deno/bin/deno /bin/deno WORKDIR /app COPY ssr/ /app/ ENTRYPOINT [&quot;deno&quot;] CMD [&quot;run&quot;, &quot;--allow-net&quot;, &quot;--allow-read&quot;, &quot;--unstable&quot;, &quot;server.tsx&quot;, &quot;-c&quot;, &quot;tsconfig.json&quot;]   Build and Run:  docker build -t deno-app . docker run -d deno-app ## output # f75f6e55675b1f8558fcfe2c34cd25f366aacc4b0f6b5df7d7982bf3cea3c46d ## Note down the output of last command docker logs f75f6e55675b   note If you notice, for first time we have run docker in detteched mode ie. docker run -d. Since we are running a long running server, We should dettached the Docket image from our sytem.  Explaination: Since we are running docker container in detteched mode. We have to grab container-id to see logs of the last docker run.  docker ps | grep todo-app docker logs f75f6e55675b   You can see output like server is running on http://localhost:8000/. However, when you try to access http://localhost:8000/ on browser. You cant access it. This is becuase docker runs container in isolation. It does not implecite expose ports out of the container. To do so, We have to expose port in docker file and same time need bind to external port while running command.  Dockerfile ## rest of the command WORKDIR /app EXPOSE 8080 COPY ssr/ /app/ ## rest of the command   Build and run with port binding:  docker build -t deno-app . docker run -d -p8000:8000 deno-app   Open http://localhost:8000/ in browser, You can see running todo app.  ","version":"Next","tagName":"h2"},{"title":"Bonus‚Äã","type":1,"pageTitle":"Run Deno Application on docker | Continuous Integration and Deployment","url":"/deno-by-example/advanced-run-on-docker#bonus","content":" I told you, That you can run file without COPY command using valume mount. For that lets remove COPY commad from Dockerfile.  Dockerfile FROM frolvlad/alpine-glibc:alpine-3.11_glibc-2.31 RUN apk update &amp;&amp; apk add curl RUN curl -fsSL https://deno.land/x/install/install.sh | sh &amp;&amp; mv /root/.deno/bin/deno /bin/deno WORKDIR /app EXPOSE 8080 ENTRYPOINT [&quot;deno&quot;] CMD [&quot;run&quot;, &quot;--allow-net&quot;, &quot;--allow-read&quot;, &quot;--unstable&quot;, &quot;server.tsx&quot;, &quot;-c&quot;, &quot;tsconfig.json&quot;]   docker build -t deno-app . docker run -d -p8000:8000 -v ${PWD}/ssr:/app deno-app   Hope you like this tutorial. Please follow me and clap for me on medium: https://deepak-v.medium.com/  ","version":"Next","tagName":"h2"},{"title":"Some Usefull Docker Commands‚Äã","type":1,"pageTitle":"Run Deno Application on docker | Continuous Integration and Deployment","url":"/deno-by-example/advanced-run-on-docker#some-usefull-docker-commands","content":" Docker Docker Images: docker images ls Running Process: docker ps Stop container: docker stop container-id Stop all container time before: docker ps | grep &quot; minutes ago&quot; | awk '{print $1}' | xargs docker stop Remove images: docker rmi -f id1 id2 id3 Logs: docker logs f75f6e55675b  Source:  You can get all source code on GitHub.examples/docker-app ","version":"Next","tagName":"h2"},{"title":"Build a CLI tool | Deno CLI minifind","type":0,"sectionRef":"#","url":"/deno-by-example/advanced-cli-minifind","content":"","keywords":"advanced cli tool grep regex","version":"Next"},{"title":"1. Input command arguments parser‚Äã","type":1,"pageTitle":"Build a CLI tool | Deno CLI minifind","url":"/deno-by-example/advanced-cli-minifind#1-input-command-arguments-parser","content":" Taking arguments in Deno is very easy. Every process has Deno.args, which returns arguments passed to the program.  examples/minifind.ts async function main(args: string[]) { console.log(args); } main(Deno.args);   Run:  deno run examples/minifind.ts param1 param2   Output:  [ &quot;param1&quot;, &quot;param2&quot; ]  Deno.args returns array of the string passed to the program(examples/minifind.ts).  Our CLI expects params like type, name, and help. To get the value of these parameters. We need to parse arguments. Deno has flags module which help to parse and collect parameters. Let's add parser.  examples/minifind.ts import { parse } from &quot;https://deno.land/std/flags/mod.ts&quot;; async function main(args: string[]) { const { type, name, not, help, _: [dir = &quot;.&quot;], } = parse(args); console.log({ type, name, not, help, dir, }); } main(Deno.args);   Run:  deno run examples/minifind.ts --help --type=f --type=d --name=&quot;.*\\.ts&quot; examples   Output:  { type: [ &quot;f&quot;, &quot;d&quot; ], name: &quot;.*\\.ts&quot;, not: undefined, help: true, dir: &quot;examples&quot; }   When you run the program with a given example, You will see the output as above. Deno parse helps you to collect all the arguments.  I have used the ES6 de-structuring feature to assign default values.  info Deno parse automatically tries to collect and combine params based on patterns. Any argument pass as prefixing --, considered as arguments with value. If you don't pass value next to it. It will become boolean.  example1:  console.log(parse([&quot;--test&quot;, &quot;t&quot;])); // { _: [], test: &quot;t&quot; } console.log(parse([&quot;--test&quot;])); // { _: [], test: true }   note Things to be noted: If you pass an argument with the same param more then once. parse combine them in array. In the above example type is passed twice. That is why, type has value [ &quot;f&quot;, &quot;d&quot; ].  example2:  console.log(parse([&quot;--test&quot;, &quot;t&quot;, &quot;--test&quot;, &quot;t2&quot;])); // { _: [], test: [ &quot;t&quot;, &quot;t2&quot; ] }   note underscore(_) here is like a collection of rest params. If arguments do not follow the standard -- or - prefix. All arguments collected in _ as an array of data. We are extracting dir as the directory name from rest _.  example3:  const { _ } = parse([&quot;--test&quot;, &quot;t&quot;, &quot;examples&quot;]); console.log(_); // _ == [ &quot;examples&quot; ] const [dir = &quot;.&quot;] = _; console.log(dir); // examples   For more info read: https://deno.land/std/flags  ","version":"Next","tagName":"h2"},{"title":"2. Traverse files and directory trees‚Äã","type":1,"pageTitle":"Build a CLI tool | Deno CLI minifind","url":"/deno-by-example/advanced-cli-minifind#2-traverse-files-and-directory-trees","content":" Since now we have arguments parsed, let's add some logic to read the directory.  The first thing we can do, We can resolve the path or directory where files need to be searched. We can use the resolve method from path module.  examples/minifind.ts import { parse } from &quot;https://deno.land/std/flags/mod.ts&quot;; import { resolve } from &quot;https://deno.land/std/path/mod.ts&quot;; async function main(args: string[]) { const { type, name, not, help, _: [dir = &quot;.&quot;], } = parse(args); const dirFullPath = resolve(Deno.cwd(), String(dir)); console.log(dirFullPath); } main(Deno.args);   Run:  deno run -A examples/minifind.ts examples   Output:  /Users/xdeepakv/github/deno-by-example/examples  note resolve require --allow-read permission. For the time being, I have given all permission passing flag -A. you can read more about permissions  Deno.cwd() is used to get current running path. We had to convert dir as a string. Since parse can convert it to string | number based on the input type.  Reading a directory can be done using Deno.readDir. But we are traversing the entire tree of directories and files. Writing the traverse method can be tricky. You can try by yourself.  Here, I will take the help of walk function from https://deno.land/std/fs/mod.ts.  examples/minifind.ts import { parse } from &quot;https://deno.land/std/flags/mod.ts&quot;; import { resolve } from &quot;https://deno.land/std/path/mod.ts&quot;; import { walk } from &quot;https://deno.land/std/fs/mod.ts&quot;; async function main(args: string[]) { const { type, name, not, help, _: [dir = &quot;.&quot;], } = parse(args); const dirFullPath = resolve(Deno.cwd(), String(dir)); for await (let entry of walk(dirFullPath)) { console.log(entry); } } main(Deno.args);   Run:  deno run -A --unstable examples/minifind.ts examples   Output:  { path: &quot;/Users/xdeepakv/github/deno-by-example/examples/sample_employee.csv&quot;, name: &quot;sample_employee.csv&quot;, isFile: true, isDirectory: false, isSymlink: false } { path: &quot;/Users/xdeepakv/github/deno-by-example/examples/06_readfile_chunk.ts&quot;, name: &quot;06_readfile_chunk.ts&quot;, isFile: true, isDirectory: false, isSymlink: false }   note Since walk function is not a stable function. We have to use --unstable flag while running the example.  Walk function returns an async generator of entries. Each entries have name and path along with other flags like isDirectory and isFile.  Nice: The toughest part has been done. Now we can read entire directories along with files in it.  ","version":"Next","tagName":"h2"},{"title":"3. Filter files/directory based on the arguments‚Äã","type":1,"pageTitle":"Build a CLI tool | Deno CLI minifind","url":"/deno-by-example/advanced-cli-minifind#3-filter-filesdirectory-based-on-the-arguments","content":" Walk function accepts WalkOptions as the second argument. We can use this option to add our logic.  Interface:  WalkOptions export interface WalkOptions { maxDepth?: number; includeFiles?: boolean; includeDirs?: boolean; followSymlinks?: boolean; exts?: string[]; match?: RegExp[]; skip?: RegExp[]; }   examples/minifind.ts // rest of the code async function main(args: string[]) { // rest of the code const dirFullPath = resolve(Deno.cwd(), String(dir)); let includeFiles = true; let includeDirs = true; let types = type ? (Array.isArray(type) ? type : [type]) : [&quot;f&quot;, &quot;d&quot;]; if (!types.includes(&quot;f&quot;)) { includeFiles = false; } if (!types.includes(&quot;d&quot;)) { includeDirs = false; } const options = { maxDepth: 2, includeFiles, includeDirs, followSymlinks: false, skip: [/node_modules/g], }; for await (const entry of walk(dirFullPath, options)) { console.log(entry.path); } } main(Deno.args);   Run:  deno run -A --unstable examples/minifind.ts examples   Output:  /Users/xdeepakv/github/deno-by-example/examples /Users/xdeepakv/github/deno-by-example/examples/subfolder /Users/xdeepakv/github/deno-by-example/examples/subfolder/dummy.ts   The default type would include both file and dir [&quot;f&quot;,&quot;d&quot;] . Users can pass flag --type=f and --type=d to override behavior.  Run- Dirs only:  deno run -A --unstable examples/minifind.ts --type=d examples   Run- Files only:  deno run -A --unstable examples/minifind.ts --type=f examples   WalkOptions supports regexp to include and exclude patterns. We can use this to filter entries by name.  examples/minifind.ts /// rest of the code async function main(args: string[]) { /// rest of the code let matchRegexps: RegExp[] | undefined = name ? (Array.isArray(name) ? name : [name]).map( (reg: string) =&gt; new RegExp(reg) ) : undefined; const options = { maxDepth: 2, includeFiles, includeDirs, followSymlinks: false, match: matchRegexps, skip: [/node_modules/g], }; for await (const entry of walk(dirFullPath, options)) { console.log(entry.path); } } main(Deno.args);   Run- Get all file name has logger in it:  deno run -A --unstable examples/minifind.ts --type=f --name=&quot;.*logger.*&quot; examples   Now we have working minifind. Noice!  ","version":"Next","tagName":"h3"},{"title":"4. Logger, better logging information‚Äã","type":1,"pageTitle":"Build a CLI tool | Deno CLI minifind","url":"/deno-by-example/advanced-cli-minifind#4-logger-better-logging-information","content":" The last missing piece is to tell your user about your CLI. For that, we have add helping messages for users. I am using logger-util created by me. You can read more herehttps://deno.land/x/deno_util.  examples/minifind.ts /// rest of the code import { Logger } from &quot;https://deno.land/x/deno_util/logger.ts&quot;; const usesFormat = `Uses:\\n\\n minifind %s`; const logger = new Logger(); function printHelp(command: string) { logger.info(`Welcome to minifind [v%s]`, &quot;1.0.0&quot;); logger.warn(usesFormat, command); } async function main(args: string[]) { /// rest of the code if (help) { printHelp(`--type=f --name=&quot;.*logger.*&quot; --help examples`); Deno.exit(0); } /// rest of the code for await (const entry of walk(dirFullPath, options)) { logger.inverse(entry.path); } } main(Deno.args);   Run with help:  deno run -A --unstable examples/minifind.ts --help   Output:    Run with other options:  deno run -A --unstable examples/minifind.ts --help   Output:    TaDa! üëèüëè Now you know how to create a CLI.  ","version":"Next","tagName":"h2"},{"title":"Bonus‚Äã","type":1,"pageTitle":"Build a CLI tool | Deno CLI minifind","url":"/deno-by-example/advanced-cli-minifind#bonus","content":" Now we have working minifind CLI. However, we had to use deno run and filename to run the command, which is not intended/feasible. Deno provides install command. We can convert any program to an executable tool.  Let's convert our minifind to executable. It is very simple.  deno install -f --allow-read --unstable examples/minifind.ts   Once you run above command you will see output like:  Add /Users/xdeepakv/.deno/bin to PATH export PATH=&quot;/Users/xdeepakv/.deno/bin:$PATH&quot;   If you see that, Just add export PATH=&quot;/Users/xdeepakv/.deno/bin:$PATH&quot; this line to you .bashrc or .bash_profile(Depending upon your OS type). Once you add .deno/bin in PATH. Open a new terminal and try below mention command.  minifind --type=f --name=&quot;.*logger.*&quot; examples   Now your minifind is ready to use product. :-)  I hope you like this tutorial. let me know your feedback in the comment. Please support(üôèüôè) by subscribing and clapping on https://deepak-v.medium.com/.  All working examples can be found in my Github: https://github.com/deepakshrma/deno-by-example/tree/master/examples ","version":"Next","tagName":"h2"},{"title":"Read Line by Line as Data Stream","type":0,"sectionRef":"#","url":"/deno-by-example/advanced-readline","content":"","keywords":"advanced stream data file network","version":"Next"},{"title":"Read Id[rid]‚Äã","type":1,"pageTitle":"Read Line by Line as Data Stream","url":"/deno-by-example/advanced-readline#read-idrid","content":" Deno provides Deno.open API to open a file. This is the async API. Meaning, you need to await. In return you will get File which contains rid.  ","version":"Next","tagName":"h2"},{"title":"Sample: open file‚Äã","type":1,"pageTitle":"Read Line by Line as Data Stream","url":"/deno-by-example/advanced-readline#sample-open-file","content":" // examples/06_readfile_chunk.ts async function main(name?: string) { if (name) { const file = await Deno.open(name); console.log(file); } } const [fileName] = Deno.args; main(fileName);   [Run]  $ deno run --allow-read examples/06_readfile_chunk.ts examples/tom.json ## Output: # File { rid: 3 }   You can see rid in return. Let's use this rid to get the chunk of data. Reading chunk requires API Deno.read  ","version":"Next","tagName":"h3"},{"title":"Example: 1‚Äã","type":1,"pageTitle":"Read Line by Line as Data Stream","url":"/deno-by-example/advanced-readline#example-1","content":" // examples/06_readfile_chunk.ts async function main(name?: string) { if (name) { const file = await Deno.open(name); const decoder = new TextDecoder(); let buf = new Uint8Array(100); const numOfByteRead = await Deno.read(file?.rid, buf); console.log(numOfByteRead); console.log(decoder.decode(buf)); } } const [fileName] = Deno.args; main(fileName);   [Run]  $ deno run --allow-read examples/06_readfile_chunk.ts examples/tom.json # Output # 100 # { # &quot;id&quot;: 1, # &quot;version&quot;: &quot;1.0.1&quot;, # &quot;contributors&quot;: [ # &quot;deepak&quot;, # &quot;gary&quot; # ], # &quot;actor&quot;: {   Here, as you can see, Every time you call Deno.read it returns the number of bytes that have been read. If numOfByteRead is null meaning it is end of file[EOF].  new Uint8Array(100); is Uint8Array to be filled while calling read. The buffer size could be anything. The reader will read bytes until buffer size.  If you notice, the read file is not a complete file. You need to increase the buff size to read all files.  ","version":"Next","tagName":"h3"},{"title":"Example: 2‚Äã","type":1,"pageTitle":"Read Line by Line as Data Stream","url":"/deno-by-example/advanced-readline#example-2","content":" // examples/06_readfile_chunk.ts async function main(name?: string) { if (name) { const file = await Deno.open(name); const decoder = new TextDecoder(); let buf = new Uint8Array(1000); // 353 const numOfByteRead = await Deno.read(file?.rid, buf); console.log(numOfByteRead); console.log(decoder.decode(buf)); } } const [fileName] = Deno.args; main(fileName);   [Run]  $ deno run --allow-read examples/06_readfile_chunk.ts examples/tom.json # Output # 353 ## JSON here..   Here in this example, I have increased buffer size to 1000, which is more than 353. So I can read the entire JSON file.  [NOTE]: You should avoid large buffer sizes. Reading a big file can create memory issues. and at the same time it will be hard to predict actual size.  To read the entire file chunk by chunk, we can use recursion on thenable API.  ","version":"Next","tagName":"h3"},{"title":"Example: 3‚Äã","type":1,"pageTitle":"Read Line by Line as Data Stream","url":"/deno-by-example/advanced-readline#example-3","content":" // examples/06_readfile_chunk.ts async function main(name?: string) { if (name) { const file = await Deno.open(name); const decoder = new TextDecoder(); let buf = new Uint8Array(100); let chunk = new Uint8Array(0); Deno.read(file?.rid, buf).then(function readByte(numOfByteRead) { if (numOfByteRead) { chunk = _append(chunk, buf, numOfByteRead); Deno.read(file?.rid, buf).then(readByte); } else { console.log(decoder.decode(chunk)); } }); } } const [fileName] = Deno.args; main(fileName);   [Run]  $ deno run --allow-read examples/06_readfile_chunk.ts examples/tom.json # Output { &quot;id&quot;: 1, &quot;version&quot;: &quot;1.0.1&quot;, &quot;contributors&quot;: [ &quot;deepak&quot;, &quot;gary&quot; ], &quot;actor&quot;: { &quot;name&quot;: &quot;Tom Cruise&quot;, &quot;age&quot;: 56, &quot;Born At&quot;: &quot;Syracuse, NY&quot;, &quot;Birthdate&quot;: &quot;July 3 1962&quot;, &quot;movies&quot;: [ &quot;Top Gun&quot;, &quot;Mission: Impossible&quot;, &quot;Oblivion&quot; ], &quot;photo&quot;: &quot;https://jsonformatter.org/img/tom-cruise.jpg&quot; } }   [Breakdown]‚Äã  Here in this code, when I call Deno.read(file?.rid, buf).then. It will trigger a named function function readByte(numOfByteRead). This will internally check for numOfByteRead each time. You can either append text return after decode by decoder.decode. I am appending as Uint8Array. To appened Uint8Array arrays, I found a good sample on StackOverflow.  [_append]‚Äã  function _append(a: Uint8Array, b: Uint8Array, numOfByteRead: number) { var c = new Uint8Array(a.length + numOfByteRead); c.set(a, 0); c.set(b.slice(0, numOfByteRead), a.length); return c; }   [NOTE]: If you don't pass numOfByteRead, you may garbage value read for last time.  Nice üôÇ, all looks fine. However, still we are away from reading line by line. For that we will use an async iterator.  ","version":"Next","tagName":"h3"},{"title":"Basic sample for Async Iterator‚Äã","type":1,"pageTitle":"Read Line by Line as Data Stream","url":"/deno-by-example/advanced-readline#basic-sample-for-async-iterator","content":" let range = { from: 1, to: 5, [Symbol.asyncIterator]() { return { current: this.from, last: this.to, async next() { const value = await new Promise&lt;number&gt;((resolve) =&gt; setTimeout(() =&gt; { resolve(this.current++); }, 1000) ); if (value &lt;= this.last) { return { done: false, value }; } else { return { done: true }; } }, }; }, }; (async () =&gt; { for await (let value of range) { console.log(value); // 1,2,3,4,5 } })();   Just like Symbol.iterator, we can use Symbol.asyncIterator to create an async Iterator. Since typescript supports async iterator out of the box. We can use this API. To understand more, you can read async-iterators-generators.  To read line by line, I have created two utility methods _readTillDone and readLine.  const _readTillDone = async ( rid: number, text: string = &quot;&quot; ): Promise&lt;[string, string, boolean]&gt; =&gt; { let buf = new Uint8Array(100); let indexOfLine = text.indexOf(&quot;\\n&quot;); if (indexOfLine === -1) { const num = await Deno.read(rid, buf); if (num) { text = text + decoder.decode(buf.slice(0, num)); return _readTillDone(rid, text); } else { return [text, &quot;&quot;, true]; } } else { return [text.slice(0, indexOfLine), text.slice(indexOfLine + 1), false]; } }; const readLine = async (fileName: string) =&gt; { const file = await Deno.open(fileName); let text = &quot;&quot;; let done = false; return { [Symbol.asyncIterator]() { return { async next() { const [t, rest, d] = await _readTillDone(file?.rid, text); if (done) { return { done: true, value: t }; } else { text = rest; done = d; return { done: false, value: t }; } }, }; }, }; };   [Breakdown]‚Äã  readLine is very simple. On each async iterator call it will call _readTillDone and return the line. However, _readTillDone is a little complex. I am using file.rid to keep track of the file read.  Whenever i call _readTillDone with file?.rid, text. It tries to split text with newLine. I could not be able to find newLine. It tries to read more lines till the end. _readTillDone returns three parameters [t, rest, d]. Here t, text read by line,rest is as buffer text and d return as done.  Let's complete the tutorial. Once we have these utils, the implementation is very simple.  ","version":"Next","tagName":"h3"},{"title":"Example: Final code‚Äã","type":1,"pageTitle":"Read Line by Line as Data Stream","url":"/deno-by-example/advanced-readline#example-final-code","content":" // examples/06_readfile_chunk.ts import { readLine } from &quot;https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/examples/file_reader.ts&quot;; async function main(name?: string) { if (name) { // Example 6 const reader = await readLine(name); for await (let value of reader) { console.log(value); } } } const [fileName] = Deno.args; main(fileName);   [Run]  $ deno run --allow-read examples/06_readfile_chunk.ts examples/tom.json # Output { &quot;id&quot;: 1, &quot;version&quot;: &quot;1.0.1&quot;, &quot;contributors&quot;: [ &quot;deepak&quot;, &quot;gary&quot; ], &quot;actor&quot;: { &quot;name&quot;: &quot;Tom Cruise&quot;, &quot;age&quot;: 56, &quot;Born At&quot;: &quot;Syracuse, NY&quot;, &quot;Birthdate&quot;: &quot;July 3 1962&quot;, &quot;movies&quot;: [ &quot;Top Gun&quot;, &quot;Mission: Impossible&quot;, &quot;Oblivion&quot; ], &quot;photo&quot;: &quot;https://jsonformatter.org/img/tom-cruise.jpg&quot; } }   TaDa! üëèüëè Now you can read the entire file line by line.  I hope you like this tutorial. let me know your feedback in the comment. Please support(üôèüôè) by subscribing and clapping on https://deepak-v.medium.com/.  All working examples can be found in my Github: https://github.com/deepakshrma/deno-by-example/tree/master/examples  Update: Recently, i got to know. That Deno does has readlines method to read reader line by line. It just documentation was missing. So i added document in Deno project. You can read it now here. https://deno.land/std/io  Sample:  import { readLines } from &quot;https://deno.land/std/io/mod.ts&quot;; import * as path from &quot;https://deno.land/std/path/mod.ts&quot;; const filename = path.join(Deno.cwd(), &quot;std/io/README.md&quot;); let fileReader = await Deno.open(filename); for await (let line of readLines(fileReader)) { console.log(line); }```  ","version":"Next","tagName":"h3"},{"title":"Take input from user | Lottery Game","type":0,"sectionRef":"#","url":"/deno-by-example/lottery-game","content":"","keywords":"CLI advanced lottery webpack game","version":"Next"},{"title":"Taking input from user‚Äã","type":1,"pageTitle":"Take input from user | Lottery Game","url":"/deno-by-example/lottery-game#taking-input-from-user","content":" To take input, We can use stdin stream from Deno as Deno.stdin. However, reading stream is very tough task Read My Blog. We can take help from readLines function. This will read stream of bytes and return whenever it found new line chars \\n.  lottery_game.ts import { readLines } from &quot;https://deno.land/std/io/mod.ts&quot;; function main() { const data = readLines(Deno.stdin).next(); console.log(data); } main();   Run:  deno run examples/lottery_game.ts   Type test and then [ENTER]‚èé  Output:  Promise { &lt;pending&gt; } test   Here if you have noticed, .next() after readLines. readLines is async iterator. So to get the value you have to call next(). This will return promise. To get value form it, we need to await for it.  import { readLines } from &quot;https://deno.land/std/io/mod.ts&quot;; async function main() { const { value: input } = await readLines(Deno.stdin).next(); console.log(&quot;You have entered: &quot; + input); } main();   Run again.Output:  test You have entered: test   Let's use logger to print in color.  lottery_game.ts import { readLines } from &quot;https://deno.land/std/io/mod.ts&quot;; import { Logger } from &quot;https://raw.githubusercontent.com/deepakshrma/deno_util/master/logger.ts&quot;; async function main() { const logger = new Logger(); const { value: input } = await readLines(Deno.stdin).next(); logger.info(&quot;You have entered: &quot; + input); } main();   You will see same output but in cyan color. Cool!  So in this lottery game, We will ask user to enter a number. If guessed number matches the lottery number then game will end. Else user has to enter another number. This game will run till user enter lottery number.  Note: To loop, We will use do-while loop.  lottery_game.ts // rest of the code async function main() { const logger = new Logger(); let matched = false; do { logger.warn(&quot;Guess the number: [1-10]&quot;); const { value } = await readLines(Deno.stdin).next(); logger.info(&quot;You have guessed: %d\\n&quot;, value); const random = Math.ceil(Math.random() * 10); logger.info(&quot;Lottery number: %d\\n&quot;, random); matched = Number(value) === random; } while (matched !== true); } main();   Output:  Guess the number: [1-10] 3 You have guessed: 3 Lottery number: 2 Guess the number: [1-10] 4 You have guessed: 4 Lottery number: 4   Breakdown:  We are taking input from user. Same time we are generating number using Math.random. First time, when user enter number 3. It does not match generated lottery number 2. Game asks user to enter again. Soon user enter 4, it matches the newly generated number 4. Game exit.  Let's make it more interactive. We will add some virtual delay to show we are generating number. And user can exit game anytime while pressing q. We will do some error validation too. So that user should not enter something not expected.  lottery_game.ts import { readLines } from &quot;https://deno.land/std/io/mod.ts&quot;; import { Logger } from &quot;https://raw.githubusercontent.com/deepakshrma/deno_util/master/logger.ts&quot;; const delay = (ms = 1000) =&gt; new Promise((r) =&gt; setTimeout(r, ms)); async function main() { const logger = new Logger(); let matched = false; let LIMIT = 10; do { logger.warn(`Guess the number: [1-${LIMIT}], Press 'q' to exit!`); let { value: guess } = await readLines(Deno.stdin).next(); guess = guess.trim(); if (guess === &quot;q&quot;) { logger.info(&quot;Thanks for playing this game! xi√® xie!&quot;); Deno.exit(0); } guess = Number(guess); if (!guess || guess &lt; 0 || guess &gt; LIMIT) { // check for NaN, repeat logger.error(`You have wrong number. Please enter number [1-${LIMIT}]\\n`); continue; } logger.info(&quot;You have guessed: %d\\n&quot;, guess); logger.warn(&quot;Generating a number...&quot;); await delay(); const random = Math.ceil(Math.random() * LIMIT); // logger.info(&quot;Lottery number: %d\\n&quot;, random); // hints const diff = guess - random; if (diff &gt; 0) { logger.info(&quot;too high!!&quot;); } else if (diff &lt; 0) { logger.info(&quot;too low!!&quot;); } else { matched = true; logger.warn(&quot;Bingo!! You have won Zoker Lottery! Enjoy!\\n&quot;); } } while (matched !== true); } main();   Run, You will see output like.    Breakdown:  delay is just a helping function to give delayguess = guess.trim(); to clean up numberguess = Number(guess); to convert in number and validate itawait delay(); virtual delay for 1 second.too high!! and too low!! to just give hint  I was lucky enough, I will lottery in 5-6 try. Haha! You can make harder, by increasing LIMIT to higher number Or removing hint to the user.  Thanks! If you like this tutorial. Please follow me, subscribe and clap for me on https://deepak-v.medium.com/  ","version":"Next","tagName":"h2"},{"title":"All working examples can be found in my Github‚Äã","type":1,"pageTitle":"Take input from user | Lottery Game","url":"/deno-by-example/lottery-game#all-working-examples-can-be-found-in-my-github","content":" https://github.com/deepakshrma/deno-by-example/tree/master/examples ","version":"Next","tagName":"h3"},{"title":"Build a GraphQL Server (From Scratch) | Deno Advanced","type":0,"sectionRef":"#","url":"/deno-by-example/advanced-graphql","content":"","keywords":"advanced route controller server graphql","version":"Next"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#introduction","content":" GraphQL is already known for its good things. GraphQL helps to build super scalable APIs. It reduces coupling between code and data provider. Deno is one of the fastest-growing frameworks/languages to build APIs. However, Deno community still new. So there is a very little framework in the Deno community. Some of them are in a very early stage of development.  In this article, I will explain how you can easily integrate the GraphQL nodejs module with Deno lang. This is a very basic implementation. However, Still, there is a lot of scope for improvements. This is not the end. This is just beginning.  ","version":"Next","tagName":"h2"},{"title":"Prerequisite‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#prerequisite","content":" Deno installed on systemBasic knowledge of Deno read more..Basic understanding of routing read more..Basic knowledge of GraphQL read more..  ","version":"Next","tagName":"h2"},{"title":"Steps‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#steps","content":" ","version":"Next","tagName":"h2"},{"title":"1. Basic project directory setup‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#1-basic-project-directory-setup","content":" First, create folders and file as described below.    mkdir src mkdir src/model src/resolvers src/routes src/schema touch README.md scripts.yaml src/server.ts ## Optional mkdir .vscode touch .vscode/settings.json   Here, src will be the directory containing all code. model is to hold all the database/models. We will create all resolvers in resolvers directory. Similarly, routes and schema to keep routes and schemas respectively. src/server.ts will be an entry for the server to start with.  ","version":"Next","tagName":"h3"},{"title":"2. Velociraptor as script runner‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#2-velociraptor-as-script-runner","content":" Deno does not have a task runner like npm. However, in Deno community, There are lots of modules we can use. I like Velociraptor. It is easy to start with an easy to integrate.  ## You can check the current version. deno install -qA -n vr https://deno.land/x/velociraptor@1.0.0-beta.16/cli.tscl   Once you install velociraptor using deno, It will be available as executable as vr. You can try to validate using vr --version. It will print the current version of the velociraptor.  Let's add basic scripts in src/server.ts  allow: - net - read - env scripts: start: cmd: deno run src/server.ts test: &quot;echo 'No Test Found'&quot; build: deno compile --unstable --allow-read --allow-net src/server.ts   Tips velociraptor supports JSON, yaml and many more formats. I like yaml version cool so I am using it.  Explained:  allow to allow net, read, and env permission to Deno executablescripts to add command.  Let's add basic hello world sever in server.ts  ","version":"Next","tagName":"h3"},{"title":"3. Basic server using Oak‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#3-basic-server-using-oak","content":" We are going to use Oak to build our backend server. It is the most stable and community supported module out there.  src/server.ts import { Application } from &quot;https://deno.land/x/oak/mod.ts&quot;; import { config } from &quot;https://deno.land/x/dotenv/mod.ts&quot;; import { Logger, LoggerOptions } from &quot;https://deno.land/x/deno_util/logger.ts&quot;; const initialOptions = { level: 0, format: &quot;%s&quot;, newLine: true }; const logger = new Logger(initialOptions as LoggerOptions); const { PORT = 4000 } = config({ safe: true }); const app = new Application(); app.use((cxt) =&gt; { cxt.response.body = &quot;Hello GraphQL&quot;; }); logger.line(`üöÄ Server is running on http://localhost:${PORT}/graphql`); await app.listen({ port: Number(PORT) });   Run:  vr start   Output:  ========================================================== || üöÄ Server is running on http://localhost:4000/graphql ==========================================================   info You may get a pop-up to allow network access to Deno when you try to run the server.  Explained:  Import oak module to create an Application.dotevn to allow create environmental variable.deno_util to create a basic logger.app.use to create basic route. Currently, It will respond Hello GraphQL to every request.  ","version":"Next","tagName":"h3"},{"title":"4. Basic mock database‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#4-basic-mock-database","content":" Since the purpose of this tutorial is not to teach you how to bind database and all. So we will mock the database as close as a real app.  Create a database.ts file touch src/model/database.ts  src/model/database.ts const users = [ { _id: &quot;6027d46771b8a91a27bc9e13&quot;, index: 0, guid: &quot;b0b80419-58a5-42ac-b488-b7c87a66f9f7&quot;, isActive: true, balance: &quot;$3,095.41&quot;, picture: &quot;http://placehold.it/32x32&quot;, age: 26, name: &quot;Hickman Beach&quot;, gender: &quot;male&quot;, email: &quot;hickmanbeach@vidto.com&quot;, phone: &quot;+1 (980) 401-2407&quot;, address: &quot;489 Canda Avenue, Buxton, Tennessee, 252&quot;, about: &quot;lorem..&quot;, registered: &quot;2020-11-16T10:40:17 -08:00&quot;, friends: [ { id: 0, name: &quot;Franklin Gentry&quot;, }, ], }, ]; export interface Friend { id: number; name: string; } export interface User { _id: string; index: number; guid: string; isActive: boolean; balance: string; picture: string; age: number; name: string; gender: string; email: string; phone: string; address: string; about: string; registered: string; friends: Friend[]; } export const getUsers = async (predicate?: (user: User) =&gt; boolean) =&gt; { if (typeof predicate === &quot;function&quot;) return users.filter(predicate); return users; };   note You can get the whole file in github repo.  Explained:  A very basic mock database with getUsers method, which returns users based on a predicate. If there is no predicate, It will return all users else apply a filter using a predicate.  ","version":"Next","tagName":"h3"},{"title":"5. Create a /graphql endpoint to handle graphql POST request‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#5-create-a-graphql-endpoint-to-handle-graphql-post-request","content":" GraphQL specs support POST to query server. We will use the same. To create a scalable routing. We will create our route in the routes folder and append it in Oak Application using the callback function.  Create files touch src/routes/index.ts src/routes/graphql.ts  Let's create gqlrouter  src/routes/graphql.ts import { Router } from &quot;https://deno.land/x/oak/mod.ts&quot;; const gqlrouter = new Router(); gqlrouter .get(&quot;/graphql&quot;, (context) =&gt; { context.response.body = &quot;Please use Post to Query&quot;; }) .post(&quot;/graphql&quot;, async (context) =&gt; { const result = context.request.body(); if (result.type === &quot;json&quot;) { const { query, variables = {} } = await result.value; if (query) { context.response.body = { query, variables }; } else { context.response.body = { message: &quot;Invalid Query&quot; }; context.response.status = 400; } } }); export default gqlrouter;   Let's update index.ts to append routes to Server.  src/routes/index.ts import { Application, Middleware, Router, } from &quot;https://deno.land/x/oak/mod.ts&quot;; import { requestTraceMiddleware } from &quot;https://deno.land/x/oak_middlewares/mod.ts&quot;; import gqlrouter from &quot;./graphql.ts&quot;; const baseRoute = new Router(); baseRoute.get(&quot;/&quot;, (context) =&gt; { context.response.body = `&lt;b&gt;Please use &lt;a href=&quot;/graphql&quot;&gt;/graphql&lt;/a&gt; to query&lt;/b&gt;`; context.response.headers.append(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); }); export default function init(app: Application) { app.use( requestTraceMiddleware&lt;Middleware&gt;({ type: &quot;combined&quot; }) ); app.use(baseRoute.routes()); app.use(gqlrouter.routes()); app.use(gqlrouter.allowedMethods()); }   Explained:  graphql.ts, We have just created an instance of Oak route. It can accept a get request and a post request at endpoint &quot;/graphql&quot;.All the GraphQL request contains query and variables as data payload.Currently, return query and variables in return response.index.ts to combine routes and apply some other middleware to Oak Application.  Let's update our server.ts  src/server.ts /// Rest of the code... import init from &quot;./routes/index.ts&quot;; const app = new Application(); init(app); /// Rest of the code...   Run:vr run start  Query using Postman:    Query using CURL:  curl --location --request POST 'http://localhost:4000/graphql' \\ --header 'Content-Type: application/json' \\ --data-raw '{&quot;query&quot;:&quot;query HelloWorld {\\n hello {\\n name\\n }\\n}&quot;,&quot;variables&quot;:{&quot;name&quot;:&quot;Hickman&quot;}}'   Output:  { &quot;query&quot;: &quot;query HelloWorld {\\n hello {\\n name\\n }\\n}&quot;, &quot;variables&quot;: { &quot;name&quot;: &quot;Hickman&quot; } }   ","version":"Next","tagName":"h3"},{"title":"6. Create GraphQL schema and resolver‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#6-create-graphql-schema-and-resolver","content":" GraphQL Executor requires schema and resolver to execute the query. For that, we need to create schema and resolver. Schema can be written in String and compile to code using buildSchema helper method. Resolvers are basic functions, will be called by graphql executor, and act on the query.  To use GraphQL Executor we have to install/use graphql module from cdn.skypack.dev  src/schema/user.ts const UserSchema = ` type Friends { id: Int name: String } type User { _id: String index: Int guid: String isActive: Boolean balance: String picture: String age: Int name: String gender: String email: String phone: String address: String about: String registered: String friends: [Friends] } `; export default UserSchema;   src/schema/index.ts import { buildSchema } from &quot;https://cdn.skypack.dev/graphql&quot;; import UserSchema from &quot;./user.ts&quot;; const base = ` type Query { hello: String users(name: String): [User] } `; export default buildSchema([base, UserSchema].join(&quot;\\n&quot;), {});   Explained:  You can use json-to-graphql, To generate graphql schemabuildSchema compile and validate schema to generate code in runtime.  note Currently, graphql does not support multi-file schema(Query). So we have to write all queries in index.ts. Hopefully, In future, we can use graphql tools.  Let's create resolvers for users and hello query  src/resolvers/hello_world.ts const HelloResolver = { Query: { hello: async (_: any, { name }: any = {}, context: any, z: any) =&gt; { return &quot;Hello world!&quot;; }, }, }; export default HelloResolver;   src/resolvers/user.ts import { getUsers } from &quot;../model/database.ts&quot;; const UserResolver = { Query: { users: async (d: any = {}, context: any) =&gt; { return getUsers(d.name ? (u: any) =&gt; u.name.includes(d.name) : undefined); }, }, }; export default UserResolver;   src/resolvers/index.ts import HelloResolver from &quot;./hello_world.ts&quot;; import UserResolver from &quot;./user.ts&quot;; const resolvers = Object.assign( {}, ...[HelloResolver, UserResolver].map((x) =&gt; x.Query) ); export default resolvers;   Explained:  user.ts and hello.ts contains an object with Query in it. The query has the function same name as it is defined in GraphQL Schema.index.ts accumulate all the resolvers.  ","version":"Next","tagName":"h3"},{"title":"7. Route to handle Query and execute‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#7-route-to-handle-query-and-execute","content":" Now we have created schema and resolver function. We can handle GraphQL requests and responses to the query. For that, we need to update our src/routes/graphql.ts.  src/routes/graphql.ts import { Router } from &quot;https://deno.land/x/oak/mod.ts&quot;; import { graphql } from &quot;https://cdn.skypack.dev/graphql&quot;; import schema from &quot;../schema/index.ts&quot;; import resolvers from &quot;../resolvers/index.ts&quot;; const gqlrouter = new Router(); gqlrouter .get(&quot;/graphql&quot;, (context) =&gt; { context.response.body = &quot;Please use Post to Query&quot;; }) .post(&quot;/graphql&quot;, async (context) =&gt; { const result = context.request.body(); if (result.type === &quot;json&quot;) { const { query, variables = {} } = await result.value; if (query) { const data = await (graphql as any)( schema, query, resolvers, { request: context.request, response: context.response, }, variables || {} ); if (data.errors) { context.response.body = data; context.response.status = 400; } else { context.response.body = data; } } else { context.response.body = { message: &quot;Invalid Query&quot; }; context.response.status = 400; } } }); export default gqlrouter;   Query using Postman:    Query using CURL:  curl --location --request POST 'http://localhost:4000/graphql' \\ --header 'Content-Type: application/json' \\ --data-raw '{&quot;query&quot;:&quot;query User($name: String){\\n users(name: $name) {\\n name\\n age\\n }\\n}&quot;,&quot;variables&quot;:{&quot;name&quot;:&quot;Hickman&quot;}}'   Output:  { &quot;data&quot;: { &quot;users&quot;: [ { &quot;name&quot;: &quot;Hickman Beach&quot;, &quot;age&quot;: 26 } ] } }   Congrats, Your GraphQL Server is ready to serve(üöÄ) the request.  ","version":"Next","tagName":"h3"},{"title":"Limitations‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#limitations","content":" As I mentioned earlier, Deno is still very new and the community is also very new. The above app has a lot of limitations. However, We shouldn't stop exploring it. Some of the limitations are highlighted below.  Support for multiple Query/AliasesMerge Schema from multiple filesConflict in resolversValidations and Proper Error Handling  ","version":"Next","tagName":"h2"},{"title":"Source Code‚Äã","type":1,"pageTitle":"Build a GraphQL Server (From Scratch) | Deno Advanced","url":"/deno-by-example/advanced-graphql#source-code","content":" deno-graphql-starter  I hope you like this tutorial. let me know your feedback in the comment. Please support(üôèüôè) by subscribing and clapping on https://deepak-v.medium.com/. ","version":"Next","tagName":"h2"},{"title":"Creating Routing/Controller in Deno Server(From Scratch)","type":0,"sectionRef":"#","url":"/deno-by-example/advanced-routing","content":"","keywords":"beginner started route controller server","version":"Next"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Creating Routing/Controller in Deno Server(From Scratch)","url":"/deno-by-example/advanced-routing#introduction","content":" Deno provides a standard package std/http for working with http/https server. However, the routing request to different Control is not supported out-of-box. Demo model is same as NodeJs. Saying that, Deno insist you to use module like oak. I will also recommend you to use this module. Here in this tutorial, I will explain how you can build Super cool Router from scratch.  üí°Learn More: https://github.com/oakserver/oak    Before creating a routing, lets create a basic server.  examples/basic_server.ts import { serve, Response } from &quot;https://deno.land/std/http/server.ts&quot;; const PORT = 8080; const server = serve({ port: PORT }); for await (const req of server) { req.respond({ body: &quot;hello world&quot; }); // respond response }   Run this deno run examples/basic_server.ts  Open browser at http://localhost:8080/. You will see hello world.  üî•Fact: If you have not read my hello-world Article. I will recommend you to please read it.  Breakdown:  Here, whenever you request anything to server. It will return you hello world in response. Adding route will be done inside for-each loop. Let's add first route.  examples/basic_server.ts import { serve, Response } from &quot;https://deno.land/std/http/server.ts&quot;; const PORT = 8080; const server = serve({ port: PORT }); console.log(`üöÄ Server is running on http://localhost:${PORT}`); for await (const req of server) { switch (req.url) { case &quot;/users&quot;: req.respond({ body: &quot;Hello Mr. Unknown&quot; }); break; default: req.respond({ body: &quot;404! Page Not Found!&quot; }); // respond response } }   Run this deno run examples/basic_server.ts  Open browser at http://localhost:8080/. You will see Hello Mr. Unknown. If you try some other URL, you will see 404! Page Not Found!.  Breakdown:  Get the current request URL using req.urlSwitch between url /users and respond accordingly.  We can do something like this. The only issue with this approach. We can't have dynamic route like /users/1234 where is 1234 is the id of user.  As solution, Instead of directly matching one to one. We can use regex to match URL and get the id of user.  examples/basic_server.ts import { serve, Response } from &quot;https://deno.land/std/http/server.ts&quot;; const PORT = 8080; const server = serve({ port: PORT }); const users = [{ name: &quot;deepak&quot; }, { name: &quot;Sam&quot; }, { name: &quot;Britney&quot; }]; console.log(`üöÄ Server is running on http://localhost:${PORT}`); for await (const req of server) { const userRegex = /^\\/users\\/(\\d+)/; const match = userRegex.exec(req.url); if (match) { const userId = Number(match[1]); if (users[userId]) { req.respond({ body: JSON.stringify(users[userId]) }); } else { req.respond({ body: &quot;USER NOT FOUND&quot; }); } } else { req.respond({ body: &quot;404! Page Not Found!&quot; }); // respond response } }   Run this deno run examples/basic_server.ts  Open browser at http://localhost:8080/. You will see {&quot;name&quot;:&quot;Sam&quot;}. If you try URL with id 5, you will see USER NOT FOUND.  Breakdown:Using regex match we achieve what we had needed. However, writing regex of complex pattern could be an issue. Let's use our first library as file. We will use path-to-regexp from pillarjs. This is the same library used by express server in nodejs.  examples/basic_server.ts import { serve, Response } from &quot;https://deno.land/std/http/server.ts&quot;; import { pathToRegexp } from &quot;https://raw.githubusercontent.com/pillarjs/path-to-regexp/master/src/index.ts&quot;; const PORT = 8080; const server = serve({ port: PORT }); const users = [{ name: &quot;deepak&quot; }, { name: &quot;Sam&quot; }, { name: &quot;Britney&quot; }]; console.log(`üöÄ Server is running on http://localhost:${PORT}`); for await (const req of server) { const userRegex = pathToRegexp(&quot;/users/:id&quot;); const match = userRegex.exec(req.url); /// rest of the code }   Re-run app again. You will see no difference. Nice!  Here adding too much business logic in same for-each loop can leads to many issue. The major concern is maintenance. So let's move to controller/handler.  examples/basic_server.ts import { serve, ServerRequest } from &quot;https://deno.land/std/http/server.ts&quot;; // Rest of the code for await (const req of server) { const userRegex = pathToRegexp(&quot;/users/:id&quot;); const match = userRegex.exec(req.url); if (match) { handleUsers(req, match); } else { req.respond({ body: &quot;404! Page Not Found!&quot; }); // respond response } } function handleUsers(req: ServerRequest, match: RegExpExecArray) { const userId = Number(match[1]); if (users[userId]) { req.respond({ body: JSON.stringify(users[userId]) }); } else { req.respond({ body: &quot;USER NOT FOUND&quot; }); } }   If you run app and request app with same input as previous. You will see same output. We just move the User logic to separate handleUsers function.  Nice! All good. However, managing these many route path and regex is tough task and hard to maintain as well.  As solution we can create a list/array of routes. The interface for Route could be  interface Route interface Route { name: string; // name of the route, just for tracking path: string; // path pattern for handler handler: (req: ServerRequest, match: RegExpExecArray) =&gt; void; // handler to handle request }   Let's create two handler. One for users, another one for posts.  Note: For time being, I am using static data from users.ts and posts.ts  handleUsers function handleUsers(req: ServerRequest, match: RegExpExecArray) { const userId = Number(match[1]); if (users[userId]) { req.respond({ body: JSON.stringify(users[userId]) }); } else { req.respond({ body: &quot;USER NOT FOUND&quot; }); } }   handlePosts function handlePosts(req: ServerRequest, match: RegExpExecArray) { const postId = Number(match[1]); if (posts[postId]) { req.respond({ body: JSON.stringify(posts[postId]) }); } else { req.respond({ body: &quot;POST NOT FOUND&quot; }); } }   Routes const routes: Route[] = [ { name: &quot;posts&quot;, path: &quot;/posts/:id&quot;, handler: handlePosts }, { name: &quot;users&quot;, path: &quot;/users/:id&quot;, handler: handleUsers }, ];   Create a handler for Page Not Found.  Page Not Handler function routeNotFound(req: ServerRequest) { req.respond({ body: &quot;404! Page Not Found!&quot; }); }   To match URL pattern, We can loop over all the routes and call the respective handler.  router function router(req: ServerRequest) { for (let route of routes) { const reg = pathToRegexp(route.path); const match = reg.exec(req.url); if (match) return route.handler(req, match); } return routeNotFound(req); }   The complete code will be like  examples/basic_server.ts import { serve, ServerRequest } from &quot;https://deno.land/std/http/server.ts&quot;; import { pathToRegexp } from &quot;https://raw.githubusercontent.com/pillarjs/path-to-regexp/master/src/index.ts&quot;; import users from &quot;./users.ts&quot;; import posts from &quot;./posts.ts&quot;; const PORT = 8080; const server = serve({ port: PORT }); console.log(`üöÄ Server is running on http://localhost:${PORT}`); interface Route { name: string; // name of the route, just for tracking path: string; // path pattern for handler handler: (req: ServerRequest, match: RegExpExecArray) =&gt; void; // handler to handle request } const routes: Route[] = [ { name: &quot;posts&quot;, path: &quot;/posts/:id&quot;, handler: handlePosts }, { name: &quot;users&quot;, path: &quot;/users/:id&quot;, handler: handleUsers }, ]; for await (const req of server) { router(req); } function handleUsers(req: ServerRequest, match: RegExpExecArray) { const userId = Number(match[1]); if (users[userId]) { req.respond({ body: JSON.stringify(users[userId]) }); } else { req.respond({ body: &quot;USER NOT FOUND&quot; }); } } function handlePosts(req: ServerRequest, match: RegExpExecArray) { const postId = Number(match[1]); if (posts[postId]) { req.respond({ body: JSON.stringify(posts[postId]) }); } else { req.respond({ body: &quot;POST NOT FOUND&quot; }); } } function router(req: ServerRequest) { for (let route of routes) { const reg = pathToRegexp(route.path); const match = reg.exec(req.url); if (match) return route.handler(req, match); } return routeNotFound(req); } function routeNotFound(req: ServerRequest) { req.respond({ body: &quot;404! Page Not Found!&quot; }); }   Don't worry, We will further break down the entire code and do required clean up.  Breakdown:  In above sample, The router function will be called on each request.This router function will loop on each Route from routes and try to match.Once match found, it will call respective handler.  Code: Code can be found at examples/basic_server.ts  Let's give final touch and break into files.  Create a controllers.ts file  examples/controllers.ts import { ServerRequest } from &quot;https://deno.land/std/http/server.ts&quot;; import { getUserById } from &quot;./users.ts&quot;; import { getPostById } from &quot;./posts.ts&quot;; const fromRoot = (str: string) =&gt; Deno.cwd() + &quot;/static/&quot; + str; export const findUserById = (req: ServerRequest, match: RegExpExecArray) =&gt; { const id = Number(match[1]); const user = getUserById(id); if (user) { req.respond({ body: JSON.stringify(user) }); } else { req.respond({ body: &quot;POST NOT FOUND&quot; }); } }; export const findPostById = (req: ServerRequest, match: RegExpExecArray) =&gt; { const id = Number(match[1]); const post = getPostById(id); if (post) { req.respond({ body: JSON.stringify(post) }); } else { req.respond({ body: &quot;POST NOT FOUND&quot; }); } }; export async function staticFile(req: ServerRequest, match: RegExpExecArray) { // handle files if (match) { const filename = match[1]; const strPath = fromRoot(filename); try { req.respond({ body: await Deno.open(strPath) }); } catch (err) { routeNotFound(req); } } else { return routeNotFound(req); } } export function routeNotFound(req: ServerRequest) { req.respond({ body: &quot;404! Page Not Found!&quot; }); }   Bonus: I have added static page handler[staticFile] for static assets.  Move all router logic in router.ts file  examples/router.ts import { ServerRequest } from &quot;https://deno.land/std/http/server.ts&quot;; import { pathToRegexp } from &quot;https://raw.githubusercontent.com/pillarjs/path-to-regexp/master/src/index.ts&quot;; import { findUserById, findPostById, routeNotFound } from &quot;./controllers.ts&quot;; interface Route { name: string; // name of the route, just for tracking path: string; // path pattern for handler handler: (req: ServerRequest, match: RegExpExecArray) =&gt; void; // handler to handle request } const routes: Route[] = [ { name: &quot;static&quot;, path: &quot;/static/:page*&quot;, handler: staticFile }, { name: &quot;posts&quot;, path: &quot;/posts/:id&quot;, handler: findUserById }, { name: &quot;users&quot;, path: &quot;/users/:id&quot;, handler: findPostById }, ]; function router(req: ServerRequest) { for (let route of routes) { const reg = pathToRegexp(route.path); const match = reg.exec(req.url); if (match) return route.handler(req, match); } return routeNotFound(req); } export default router;   Finally the main server with request logger: final_server.ts  examples/final_server.ts import { serve } from &quot;https://deno.land/std/http/server.ts&quot;; import router from &quot;./router.ts&quot;; import { Logger } from &quot;https://raw.githubusercontent.com/deepakshrma/deno_util/master/logger.ts&quot;; const logger = new Logger(); const PORT = 8080; const server = serve({ port: PORT }); console.log(`üöÄ Server is running on http://localhost:${PORT}`); for await (const req of server) { logger.info(&quot;/%s:\\t%s \\t\\t%s&quot;, req.method, req.url, new Date().toISOString()); router(req); }   Run this deno run examples/final_server.ts  Open browser at http://localhost:8080/static/home.html. You will see Magic.    Good Job! Thanks for support in advance. Please do follow me, subscribing and clapping on https://deepak-v.medium.com/  ","version":"Next","tagName":"h2"},{"title":"All working examples can be found in my Github‚Äã","type":1,"pageTitle":"Creating Routing/Controller in Deno Server(From Scratch)","url":"/deno-by-example/advanced-routing#all-working-examples-can-be-found-in-my-github","content":" https://github.com/deepakshrma/deno-by-example/tree/master/examples ","version":"Next","tagName":"h3"},{"title":"Building A Super Cool Colorful Logger with Deno fmt module","type":0,"sectionRef":"#","url":"/deno-by-example/advanced-logger","content":"","keywords":"advanced CLI data file tools","version":"Next"},{"title":"Prerequisites‚Äã","type":1,"pageTitle":"Building A Super Cool Colorful Logger with Deno fmt module","url":"/deno-by-example/advanced-logger#prerequisites","content":" Deno: Install Deno if you don't have it installedBasic-Typescript: basic-types  Just like Nodejs/JavaScript. Logging can be done using console.log  console.log(&quot;Hello World&quot;);   Nice! However formatting log message is big pain is javascript. console.log partially implements functions like printf from c++ or java. But it doesn't support all the features.  So how we should log formatted messages?  ","version":"Next","tagName":"h2"},{"title":"Formatted Log in JS‚Äã","type":1,"pageTitle":"Building A Super Cool Colorful Logger with Deno fmt module","url":"/deno-by-example/advanced-logger#formatted-log-in-js","content":" Using String template.  const name = &quot;Deepak&quot;; const salary = 2000; console.log(`My name is ${name} and my salary is ${salary}$`); // My name is Deepak and my salary is 2000$   Cool! But we can see for each parameter in the template, we have to give you a constant/variable. It will be hard to create variables just to log something.  Using Vargs in console.log.  const name = &quot;Deepak&quot;; const salary = 2000; console.log(`My name and salary are `, name, salary); // My name and salary are Deepak 2000 const person = { name: &quot;deepak&quot;, salary: 2000 }; console.log(`Info: `, person); // Info: { name: 'deepak', salary: 2000 }   The above statement is valid in javascript. We can pass any number of vargs to console.log However, we can't arrange the message with variables. This is very useful to print anything just by separating value from comma. But this can not be used for logging something useful.  ","version":"Next","tagName":"h3"},{"title":"Issues with vargs‚Äã","type":1,"pageTitle":"Building A Super Cool Colorful Logger with Deno fmt module","url":"/deno-by-example/advanced-logger#issues-with-vargs","content":" Unpredicted implementationError-prone  Let's see by an example:  const person = { name: &quot;deepak&quot;, salary: 2000 }; const address = { street: &quot;221B baker street london&quot;, zip: 20000 }; console.log(&quot;Person info: &quot; + person + &quot; Address: &quot; + address); // Person info: [object Object] Address: [object Object]   If you try to append the object with string it converts to the string which is [object Object] for object and appended.  Solution:  const person = { name: &quot;deepak&quot;, salary: 2000 }; const address = { street: &quot;221B baker street london&quot;, zip: 20000 }; console.log( &quot;Person info: &quot; + JSON.stringify(person) + &quot; Address: &quot; + JSON.stringify(address) ); // Person info: {&quot;name&quot;:&quot;deepak&quot;,&quot;salary&quot;:2000} Address: {&quot;street&quot;:&quot;221B baker street london&quot;,&quot;zip&quot;:20000} // Or console.log(&quot;Person info: &quot;, person, &quot; Address: &quot;, address); // Person info: { name: 'deepak', salary: 2000 } Address: { street: '221B baker street london', zip: 20000 }   Use Partial printf like feature in console.log.  const person = { name: &quot;deepak&quot;, salary: 2000 }; const address = { street: &quot;221B baker street london&quot;, zip: 20000 }; console.log( &quot;Person info: name: %s salary: %d and Address: street: %s &quot;, person.name, person.salary, address.street ); // Person info: name: deepak salary: 2000 and Address: street: 221B baker street london   Here you can see, console.log does support printf like functions. However, this is limited until %s [string], %d [number]. Mozilla does support Precision formatting something like %.2f.  ","version":"Next","tagName":"h3"},{"title":"Introduction to PrintF‚Äã","type":1,"pageTitle":"Building A Super Cool Colorful Logger with Deno fmt module","url":"/deno-by-example/advanced-logger#introduction-to-printf","content":" Deno is highly inspired by Go. Just like Go, Deno also has fmt module in the standard library. This module/package is a combination of multiple sub-modules like printf.  Note: fmt module is still in work-in-progress status according to developers.  Importing printf:  import { printf } from &quot;https://deno.land/std/fmt/printf.ts&quot;;   Definition of printf:  export function printf(format: string, ...args: unknown[]): void { const s = sprintf(format, ...args); Deno.stdout.writeSync(new TextEncoder().encode(s)); }   printf takes string and vars of unknown. The format is to define what the format of the string will look like. args could be anything according to the format you wanted.  Sample of printf:  const person = { name: &quot;deepak&quot;, salary: 2000 }; printf(`Person Name: &quot;%s&quot; and Salary: %d\\n`, person.name, person.salary); // Person Name: &quot;deepak&quot; and Salary: 2000   ","version":"Next","tagName":"h3"},{"title":"According to Deno documents‚Äã","type":1,"pageTitle":"Building A Super Cool Colorful Logger with Deno fmt module","url":"/deno-by-example/advanced-logger#according-to-deno-documents","content":" The following verbs are supported:  Verb\tMeaning%\tprint a literal percent t\tevaluate arg as boolean, print true or false b\teval as number, print binary c\teval as number, print character corr. to the codePoint o\teval as number, print octal x X\tprint as hex (ff FF), treat string as list of bytes e E\tprint number in scientific/exponent format 1.123123e+01 f F\tprint number as float with decimal point and no exponent g G\tuse %e %E or %f %F depending on size of argument s\tinterpolate string T\ttype of arg, as returned by typeof v\tvalue of argument in 'default' format (see below) j\targument as formatted by JSON.stringify  Verbs with Width and Precision  %9f width 9, default precision %.9f default width, precision 9 %8.9f width 8, precision 9 %8.f width 9, precision 0  Sample of Width and Precision:  const person = { name: &quot;deepak&quot;, salary: 2000.2 }; printf(`Person Name: &quot;%s&quot; and Salary: %9.2f\\n`, person.name, person.salary); // Person Name: &quot;deepak&quot; and Salary: 2000.20   You can write more complex examples like padding and get the value of the vargs passed to printf function.  Sample of Padding:  const person = { name: &quot;deepak&quot;, salary: 2000.2 }; // Padding Zero printf(`Salary: %09.2f\\n`, person.salary); // Salary: 002000.20   The conversion of rgb to hex color is so simple.  const r = 5, g = 255, b = 100; printf(&quot;RGB TO HEX: #%02x%02x%02x\\n&quot;, r, g, b); // RGB TO HEX: #05ff64   More Complex use index of vargs values:  const person = { name: &quot;deepak&quot;, salary: 2000.2 }; printf( &quot;Person has salary %d, which(%[1]d) is less than average salary %d\\n&quot;, person.salary, 4000 ); // Person has salary 2000.2, which(2000.2) is less than average salary 4000   Read More: https://deno.land/std/fmt  ","version":"Next","tagName":"h3"},{"title":"Colors in Log‚Äã","type":1,"pageTitle":"Building A Super Cool Colorful Logger with Deno fmt module","url":"/deno-by-example/advanced-logger#colors-in-log","content":" THE DOOR IS RED HERE THE WRITER USES THE COLOR TO EXPRESS HIS ANGER    Another issue with console.log, It does not support colors out of the box. We end-up adding libraries like colors in NodeJs. The browser has some additional support for css console.log. But that will not work in NodeJs  Read More: https://developer.mozilla.org/en-US/docs/Web/API/console  Thanks to Deno's Colors module. Now we can easily color our life.  Importing colors:  import { red, yellow, gray, cyan } from &quot;https://deno.land/std/fmt/colors.ts&quot;;   Note: colors module also supports rgb colors  import { rgb8, bgRgb8, rgb24 } from &quot;https://deno.land/std/fmt/colors.ts&quot;;   From Deno source:  /** Set background color using paletted 8bit colors. * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */ export function bgRgb8(str: string, color: number): string { return run(str, code([48, 5, clampAndTruncate(color)], 49)); }   Now, We have all the basic tools. Let's finish the Logger implementation‚Äã    ","version":"Next","tagName":"h3"},{"title":"Create a Basic Logger Class‚Äã","type":1,"pageTitle":"Building A Super Cool Colorful Logger with Deno fmt module","url":"/deno-by-example/advanced-logger#create-a-basic-logger-class","content":" Define interfaces:  import { sprintf, printf } from &quot;https://deno.land/std/fmt/printf.ts&quot;; import { red, yellow, gray, cyan } from &quot;https://deno.land/std/fmt/colors.ts&quot;; type LogLevel = 0 | 1 | 2 | 3; interface LoggerOptions { level: LogLevel; format?: string; }   Create a constructor and define default values for log level and format:  import { sprintf, printf } from &quot;https://deno.land/std/fmt/printf.ts&quot;; import { red, yellow, gray, cyan } from &quot;https://deno.land/std/fmt/colors.ts&quot;; type LogLevel = 0 | 1 | 2 | 3; interface LoggerOptions { level: LogLevel; format?: string; } const initialOptions = { level: 0, format: &quot;%s\\n&quot; }; class Logger { private _level: LogLevel; private _format: string; constructor(options: LoggerOptions = initialOptions as LoggerOptions) { const { level, format } = { ...initialOptions, ...options }; this._level = level; this._format = format; } }   Define getter setter for level and format:  const initialOptions = { level: 0, format: &quot;%s\\n&quot; }; class Logger { private _level: LogLevel; private _format: string; /// rest of the code get level(): LogLevel { return this._level; } set level(_l: LogLevel) { this._level = _l; } get format(): string { return this._format; } set format(_f: string) { this._format = _f; } }   Note: This is to hide the definition. You can remove setters if you don't want user to modify the values.  Add basic methods:  const initialOptions = { level: 0, format: &quot;%s\\n&quot; }; class Logger { private _level: LogLevel; private _format: string; /// rest of the code log(...messages: unknown[]) { printf(gray(sprintf(this.format, ...messages))); } info(...messages: unknown[]) { printf(cyan(sprintf(this.format, ...messages))); } warn(...messages: unknown[]) { printf(yellow(sprintf(this.format, ...messages))); } error(...messages: unknown[]) { printf(red(sprintf(this.format, ...messages))); } }   Sample Run:  import { Logger } from &quot;./logger.ts&quot;; const logger = new Logger({ level: 0, format: &quot;Logger: %s&quot; }); logger.log(&quot;This is log message&quot;); logger.info(&quot;This is info&quot;); logger.warn(&quot;This is warn&quot;); logger.error(&quot;This is error&quot;);   Output:    If you notice, I am using sprintf before using printf. Since I want the full control on the printing message like adding colors and using the dynamic format. I have to use sprintf instead of printf.  Let's allow the user to modify format at runtime:  const initialOptions = { level: 0, format: &quot;%s\\n&quot; }; class Logger { private _level: LogLevel; private _format: string; /// rest of the code log(format: string, ...messages: unknown[]) { if (messages.length === 0) { messages = [format]; format = this.format; } printf(gray(sprintf(format, ...messages))); } info(format: string, ...messages: unknown[]) { if (messages.length === 0) { messages = [format]; format = this.format; } printf(cyan(sprintf(format, ...messages))); } warn(format: string, ...messages: unknown[]) { if (messages.length === 0) { messages = [format]; format = this.format; } printf(yellow(sprintf(format, ...messages))); } error(format: string, ...messages: unknown[]) { if (messages.length === 0) { messages = [format]; format = this.format; } printf(red(sprintf(format, ...messages))); } }   Sample Run2:  import { Logger } from &quot;./logger.ts&quot;; const logger = new Logger({ level: 0, format: &quot;Logger: %s&quot; }); logger.log(&quot;This is log message&quot;); logger.warn(&quot;This is warn&quot;); logger.log( &quot;Overridden Info- Method: //%s %s [response time]: %05f ms&quot;, &quot;POST&quot;, &quot;https://www.google.com&quot;, 100 ); logger.error( &quot;Overridden Error- Error: //%s&quot;, new Error(&quot;This is error&quot;).message );   Output:    Final Touch: Use of log levels‚Äã  const initialOptions = { level: 0, format: &quot;%s\\n&quot; }; class Logger { private _level: LogLevel; private _format: string; /// rest of the code log(format: string, ...messages: unknown[]) { if (this.level &gt; 0) return; if (messages.length === 0) { messages = [format]; format = this.format; } printf(gray(sprintf(format, ...messages))); } /// rest of the code }   Final Run:  import { Logger } from &quot;./logger.ts&quot;; const logger = new Logger({ level: 0, format: &quot;Logger: %s&quot; }); logger.log(&quot;This is log message&quot;); logger.warn(&quot;This is warn&quot;); logger.log( &quot;Overridden Info- Method: //%s %s [response time]: %05f ms&quot;, &quot;POST&quot;, &quot;https://www.google.com&quot;, 100 ); logger.error( &quot;Overridden Error- Error: //%s&quot;, new Error(&quot;This is error&quot;).message ); // Change level logger.level = 2; // This will not print logger.log( &quot;Overridden Info- Method: //%s %s [response time]: %05f ms&quot;, &quot;POST&quot;, &quot;https://www.google.com&quot;, 100 ); // This will print logger.error( &quot;Overridden Error- Error: //%s&quot;, new Error(&quot;This is error&quot;).message ); // Change default format logger.level = 1; logger.format = &quot;This is something new version: v%s&quot;; logger.info(&quot;1.0.1&quot;); logger.info(&quot;1.0.2&quot;);   Output:    Good Job Nice! Well done! We have done it!!    The entire implementation of Logger class can be found in examples/logger.ts  How to use sample can be found in examples/advance_logger.ts  For more examples like this, visit: https://decipher.dev/deno-by-example  I hope you like this tutorial. let me know your feedback in the comment. Please support(üôèüôè) by subscribing and clapping on https://deepak-v.medium.com/. ","version":"Next","tagName":"h3"},{"title":"Build an Isomorphic Application using Deno and React without WebPack","type":0,"sectionRef":"#","url":"/deno-by-example/advanced-react-ssr","content":"","keywords":"deno isomorphic ssr bundle advanced server-side-render","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#overview","content":" According to the wiki, An isomorphic JavaScript(also known as Universal JavaScript) is described as JavaScript applications that run both on the client and the server.    If I say, you can build an entire SSR without setting up installing any external nodejs dependency. Would you believe it? I guess NO.  However, In this tutorial, I will explain how to set up a simple SSR app without installing a single nodejs library or bundler. That also including a hydrate react app(isomorphic app).  ","version":"Next","tagName":"h2"},{"title":"Set-up‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#set-up","content":" ","version":"Next","tagName":"h2"},{"title":"Start with npm init‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#start-with-npm-init","content":" Don‚Äôt be afraid, To do things differently, we will not install any nodejs libraries. However, I still like npm as a task runner. So let‚Äôs use it. Create a folder SSR and init npm package.json  md -p examples/ssr cd examples/ssr ## init npm package npm init --y   ","version":"Next","tagName":"h3"},{"title":"Backend‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#backend","content":" Add Basic deno server: Create server.tsx a file and add below code  server.tsx import { Application, Router } from &quot;https://deno.land/x/oak@v6.0.1/mod.ts&quot;; const app = new Application(); const router = new Router(); router.get(&quot;/&quot;, handlePage); app.use(router.routes()); app.use(router.allowedMethods()); console.log(&quot;server is running on http://localhost:8000/&quot;); await app.listen({ port: 8000 }); function handlePage(ctx: any) { try { ctx.response.body = `&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body &gt; &lt;div id=&quot;root&quot;&gt;&lt;h1&gt;Hello SSR&lt;/h1&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;`; } catch (error) { console.error(error); } }   note We will use oak module here to create Deno server. You can create your own server. For that read my article Creating Routing/Controller in Deno Server(From Scratch)  Add below command in package.json.  &quot;scripts&quot;: { &quot;start&quot;: &quot;deno run --allow-net server.ts&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; },   Run:Now we can run the application and verify on http://localhost:8000/.  npm run start   ","version":"Next","tagName":"h2"},{"title":"Add React Server Render‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#add-react-server-render","content":" Now we can run the application. Let us add our first rendering code. For that, we need to ReactJS. Since Deno uses ES Module import, We will use the CDN hosted version of react and react-dom. For that, there is a good CDN provider https://jspm.dev/.  jspm jspm provides a module CDN allowing any package from npm to be directly loaded in the the browser and other JS environments as a fully optimized native JavaScript module.  Now since we are going to write some TSX syntax(typescript JSX). We have to change the file extension of server.ts to server.tsx. Let‚Äôs do that and update package.json.  mv server.ts server.tsx   package.json &quot;scripts&quot;: { &quot;start&quot;: &quot;deno run --allow-net server.tsx&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; },   Create a common dependency deps.ts file  deps.ts // @deno-types=&quot;https://denopkg.com/soremwar/deno_types/react/v16.13.1/react.d.ts&quot; import React from &quot;https://jspm.dev/react@17.0.2&quot;; // @deno-types=&quot;https://denopkg.com/soremwar/deno_types/react-dom/v16.13.1/server.d.ts&quot; import ReactDOMServer from &quot;https://jspm.dev/react-dom@17.0.2/server&quot;; // @deno-types=&quot;https://denopkg.com/soremwar/deno_types/react-dom/v16.13.1/react-dom.d.ts&quot; import ReactDOM from &quot;https://jspm.dev/react-dom@17.0.2&quot;; export { React, ReactDOM, ReactDOMServer };   Add below lines in server.tsx  server.tsx import { Application, Router } from &quot;https://deno.land/x/oak@v6.0.1/mod.ts&quot;; import { React, ReactDOMServer, ReactDOM } from &quot;./dep.ts&quot;; const app = new Application(); const router = new Router(); router.get(&quot;/&quot;, handlePage); app.use(router.routes()); app.use(router.allowedMethods()); console.log(&quot;server is running on http://localhost:8000/&quot;); await app.listen({ port: 8000 }); function App() { return &lt;h1&gt;Hello SSR&lt;/h1&gt;; } function handlePage(ctx: any) { try { const body = ReactDOMServer.renderToString(&lt;App /&gt;); ctx.response.body = `&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body &gt; &lt;div id=&quot;root&quot;&gt;${body}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;`; } catch (error) { console.error(error); } }   Run the app again. You will see errors on the console.  TS7026 [ERROR] TS7026 [ERROR]: JSX element implicitly has type 'any' because no interface 'JSX.IntrinsicElements' exists. return Hello SSR  This error is due to missing typings to react. Since we do not include types to react. We have to let know the typescript compiler. How it should treat JSX(TSX) syntax.  To suppress these errors, Add below lines.  server.tsx function App() { return &lt;h1&gt;Hello SSR&lt;/h1&gt;; }   Now run the server again. You can see your first React SSR running on the browser. Nice!  ","version":"Next","tagName":"h3"},{"title":"Adding Server Controller- Create Backend APIs‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#adding-server-controller--create-backend-apis","content":" Let‚Äôs move further and start adding a few core features for Server. Let‚Äôs add some server-side data for our app. For that, we will include a few routes on Oak Server. Oak  server.tsx const router = new Router(); router.get(&quot;/&quot;, handlePage); let todos: Map&lt;number, any&gt; = new Map(); function init() { todos.set(todos.size + 1, { id: Date.now(), task: &quot;build an ssr deno app&quot; }); todos.set(todos.size + 1, { id: Date.now(), task: &quot;write blogs on deno ssr&quot;, }); } init(); router .get(&quot;/todos&quot;, (context) =&gt; { context.response.body = Array.from(todos.values()); }) .get(&quot;/todos/:id&quot;, (context) =&gt; { if ( context.params &amp;&amp; context.params.id &amp;&amp; todos.has(Number(context.params.id)) ) { context.response.body = todos.get(Number(context.params.id)); } else { context.response.status = 404; } }) .post(&quot;/todos&quot;, async (context) =&gt; { const body = context.request.body(); if (body.type === &quot;json&quot;) { const todo = await body.value; todos.set(Date.now(), todo); } context.response.body = { status: &quot;OK&quot; }; }); app.use(router.routes()); app.use(router.allowedMethods());   Here in the above code, We have created three routes.  GET /todos/ to get a list of the todosGET /todos/:id to todo by idPOST /todos/ create a new todo  function init() to create some initial dummy todos. You can use postman to try-out get and post data.  ","version":"Next","tagName":"h3"},{"title":"Client Side App‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#client-side-app","content":" ","version":"Next","tagName":"h2"},{"title":"Add List Todos to React App‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#add-list-todos-to-react-app","content":" Since now we have API to create todos and consume todos. Let‚Äôs list down all this on our react app. For that add the below-mentioned code.  server.tsx function App() { return ( &lt;div&gt; &lt;div className=&quot;jumbotron jumbotron-fluid&quot;&gt; &lt;div className=&quot;container&quot;&gt; &lt;h1 className=&quot;display-4&quot;&gt;ToDo's App&lt;/h1&gt; &lt;p className=&quot;lead&quot;&gt;This is our simple todo app.&lt;/p&gt; &lt;ListTodos items={Array.from(todos.values())} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); } interface Todo { task: string; } interface ListTodos{ items: Todo[] } function ListTodos({ items = [] }: ListTodos) { return ( &lt;div&gt; &lt;ul className=&quot;list-group&quot;&gt; {items.map((todo: any, index: number) =&gt; { return ( &lt;li key={index} className=&quot;list-group-item&quot;&gt; {todo.task} &lt;button type=&quot;button&quot; className=&quot;ml-2 mb-1 close&quot; aria-label=&quot;Close&quot; &gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; ); })} &lt;/ul&gt; &lt;/div&gt; ); } function handlePage(ctx: any) { try { const body = ReactDOMServer.renderToString(&lt;App /&gt;); ctx.response.body = `&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body &gt; &lt;div id=&quot;root&quot;&gt;${body}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;`;   Update all the changes and run the app. You will see a list of Todos containing two rows of initial data. You can use curl post data to route POST/todos/ to create new records. Once you add a post, refresh the page, You will see added new post data.  post data using curl curl --header &quot;Content-Type: application/json&quot; \\ --request POST \\ --data '{&quot;task&quot;:&quot;Create postman script&quot;}' \\ http://localhost:8000/todos/   bootstrap If you noticed, I have added basic bootstrap to make UI nicer. You can use some other CSS library.    Tada! Now you have running the SSR app. You can replace the in-memory todos store to any persistent database. The result will be the same.  Now time to add some interactive behavior in Our react app(client-side). But before doing that, let‚Äôs move our react code to some separate file app.tsx.  Create a file app.tsx:  app.tsx import { React } from &quot;./dep.ts&quot;; /* // enable in case of old react module declare global { namespace JSX { interface IntrinsicElements { [key: string]: any; } } } */ interface AppProps { todos?: Todo[]; } interface Todo { task: string; } function App({ todos = [] }: AppProps) { return ( &lt;div&gt; &lt;div className=&quot;jumbotron jumbotron-fluid&quot;&gt; &lt;div className=&quot;container&quot;&gt; &lt;h1 className=&quot;display-4&quot;&gt;ToDo's App&lt;/h1&gt; &lt;p className=&quot;lead&quot;&gt;This is our simple todo app.&lt;/p&gt; &lt;ListTodos items={todos} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); } interface ListTodos { items: Todo[]; } function ListTodos({ items = [] }: ListTodos) { return ( &lt;div&gt; &lt;ul className=&quot;list-group&quot;&gt; {items.map((todo: any, index: number) =&gt; { return ( &lt;li key={index} className=&quot;list-group-item&quot;&gt; {todo.task} &lt;button type=&quot;button&quot; className=&quot;ml-2 mb-1 close&quot; aria-label=&quot;Close&quot; &gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; ); })} &lt;/ul&gt; &lt;/div&gt; ); } export default App;   note Notice the change in the App component. Since we do not have direct access to todos now, We need to pass data as props while rendering it. Corresponding changes have been done for ListTodos.  server.tsx import { React, ReactDOMServer, ReactDOM } from &quot;./dep.ts&quot;; import App from &quot;./app.tsx&quot;; /// rest of the code function handlePage(ctx: any) { try { const body = ReactDOMServer.renderToString( &lt;App todos={Array.from(todos.values())} /&gt; // change here to pass todos as props ); // rest of the code }   Run the app and see changes on the browser, If all good there will be no change in the final output.  ","version":"Next","tagName":"h3"},{"title":"Adding delete functionality on client-side‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#adding-delete-functionality-on-client-side","content":" app.tsx function ListTodos({ items = [] }: ListTodos) { const [deletedIdxs, setDeletedIdxs] = (React as any).useState([]); return ( &lt;&gt; &lt;ul className=&quot;list-group&quot;&gt; {items.map((todo: any, index: number) =&gt; { const deleted = deletedIdxs.indexOf(index) !== -1; return ( &lt;li key={index} className=&quot;list-group-item&quot; style={{ color: deleted &amp;&amp; &quot;red&quot; }} &gt; {todo.task} &lt;button type=&quot;button&quot; className=&quot;ml-2 mb-1 close&quot; aria-label=&quot;Close&quot; onClick={() =&gt; setDeletedIdxs([...deletedIdxs, index])} &gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; ); })} &lt;/ul&gt; &lt;/&gt; ); }   Once you do the above changes and try to delete by clicking on cross-button. You will see no change in UI. By code, it should turn the element color to red. So what could be the reason for that?  Answer: Hydrate  Since we are using ReactDOMServer.renderToString the library which converts React app to string. So we lose all JS capabilities. To re-enable react js on the client-side. For that React provides you Hydrate module(API). This hydrate API re-enable the react feature on the client-side again. This makes our app Isomorphic app. More: Hydrate  Adding hydrate is a tough task to do. But Awesome Deno shines well here too. Deno provides Bundle API to convert a script to js. We will use Deno.emit to create hydrate js for the client-side.  Create a new file client.tsx and add below codes:  client.tsx import { React, ReactDOM } from &quot;./dep.ts&quot;; import App from &quot;./app.tsx&quot;; (ReactDOM as any).hydrate(&lt;App todos={[]} /&gt;, document.getElementById(&quot;root&quot;));   Add below codes to compile and convert client.tsx to serve as a route in our server.  server.tsx // initial code const { files } = await Deno.emit(&quot;./client.tsx&quot;, { bundle: &quot;module&quot; }); const clientJS = files[&quot;deno:///bundle.js&quot;] || &quot;&quot;; const serverrouter = new Router(); serverrouter.get(&quot;/static/client.js&quot;, (context) =&gt; { context.response.headers.set(&quot;Content-Type&quot;, &quot;text/html&quot;); context.response.body = clientJS; }); app.use(router.routes()); app.use(serverrouter.routes()); // rest of the code function handlePage(ctx: any) { try { const body = ReactDOMServer.renderToString( &lt;App todos={Array.from(todos.values())} /&gt; // change here to pass todos as props ); ctx.response.body = `&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;!--Rest of the code --&gt; &lt;div id=&quot;root&quot;&gt;${body}&lt;/div&gt; &lt;script src=&quot;http://localhost:8000/static/client.js&quot; defer&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`; } catch (error) { console.error(error); }   Since we are using unstable API deno.emit, You have to update package.json and add more flags. Same time, We are using DOM with typescript. So we have to add custom tsconfig.json.  package.json { &quot;scripts&quot;: { &quot;start&quot;: &quot;deno run --allow-net --allow-read --unstable server.tsx -c tsconfig.json&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; } }   tsconfig.json { &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es6&quot; /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */, &quot;module&quot;: &quot;commonjs&quot; /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */, &quot;lib&quot;: [ &quot;DOM&quot;, &quot;ES2017&quot;, &quot;deno.ns&quot; ] /* Specify library files to be included in the compilation. */, &quot;strict&quot;: true /* Enable all strict type-checking options. */, &quot;esModuleInterop&quot;: true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */, &quot;skipLibCheck&quot;: true /* Skip type checking of declaration files. */, &quot;forceConsistentCasingInFileNames&quot;: true /* Disallow inconsistently-cased references to the same file. */ } }   note You can use runtime compile as CLI to convert client.tsx before even starting the server. However, I just wanna show a cool way of doing it. So I use Deno.emit on runtime.  ","version":"Next","tagName":"h3"},{"title":"Final Touch‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#final-touch","content":" ","version":"Next","tagName":"h2"},{"title":"Initialize initial state‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#initialize-initial-state","content":" Once you do all the above-mentioned changes, Re-Run app. You will notice the list is the visible and hidden same time. This is because we react hydrate start working and it is trying to re-initialize the app. So all the data we render from the server is gone to persist data we need to pass data as application initial data. There are a lot of patterns to pass initial data. We will use the simple window global data.  Let‚Äôs start data on the window after making below changes on the given files.  server.tsx function handlePage(ctx: any) { try { const body = ReactDOMServer.renderToString( &lt;App todos={[]} /&gt; ); ctx.response.body = `&lt;!DOCTYPE html&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.__INITIAL_STATE__ = {&quot;todos&quot;: ${JSON.stringify( Array.from(todos.values()) )}}; &lt;/script&gt; &lt;/head&gt;   client.tsx // initial codes declare global { var __INITIAL_STATE__: any; } import App from &quot;./app.tsx&quot;; const { todos } = window.__INITIAL_STATE__ || { todos: [] }; (ReactDOM as any).hydrate( &lt;App todos={todos} /&gt;, document.getElementById(&quot;root&quot;) );   After the changes, all the files will look as below.  app.tsx import { React } from &quot;./dep.ts&quot;; interface AppProps { todos?: Todo[]; } interface Todo { task: string; } function App({ todos = [] }: AppProps) { return ( &lt;div&gt; &lt;div className=&quot;jumbotron jumbotron-fluid&quot;&gt; &lt;div className=&quot;container&quot;&gt; &lt;h1 className=&quot;display-4&quot;&gt;ToDo's App&lt;/h1&gt; &lt;p className=&quot;lead&quot;&gt;This is our simple todo app.&lt;/p&gt; &lt;ListTodos items={todos} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); } interface ListTodos { items: Todo[]; } function ListTodos({ items = [] }: ListTodos) { const [deletedIdxs, setDeletedIdxs] = (React as any).useState([]); return ( &lt;div&gt; &lt;ul className=&quot;list-group&quot;&gt; {items.map((todo: any, index: number) =&gt; { const deleted = deletedIdxs.indexOf(index) !== -1; return ( &lt;li key={index} className=&quot;list-group-item&quot; style={{ color: deleted ? &quot;red&quot; : &quot;green&quot; }} &gt; {todo.task} &lt;button type=&quot;button&quot; className=&quot;ml-2 mb-1 close&quot; aria-label=&quot;Close&quot; onClick={() =&gt; setDeletedIdxs([...deletedIdxs, index])} &gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/li&gt; ); })} &lt;/ul&gt; &lt;/div&gt; ); } export default App;   client.tsx import { React, ReactDOM } from &quot;./dep.ts&quot;; declare global { var __INITIAL_STATE__: any; } import App from &quot;./app.tsx&quot;; const { todos } = window.__INITIAL_STATE__ || { todos: [] }; (ReactDOM as any).hydrate( &lt;App todos={todos} /&gt;, document.getElementById(&quot;root&quot;) );   server.tsx import { Application, Router } from &quot;https://deno.land/x/oak@v6.0.1/mod.ts&quot;; import { React, ReactDOMServer } from &quot;./dep.ts&quot;; import App from &quot;./app.tsx&quot;; const app = new Application(); const router = new Router(); router.get(&quot;/&quot;, handlePage); let todos: Map&lt;number, any&gt; = new Map(); function init() { todos.set(todos.size + 1, { id: Date.now(), task: &quot;build an ssr deno app&quot; }); todos.set(todos.size + 1, { id: Date.now(), task: &quot;write blogs on deno ssr&quot;, }); } init(); router .get(&quot;/todos&quot;, (context: any) =&gt; { context.response.body = Array.from(todos.values()); }) .get(&quot;/todos/:id&quot;, (context: any) =&gt; { if ( context.params &amp;&amp; context.params.id &amp;&amp; todos.has(Number(context.params.id)) ) { context.response.body = todos.get(Number(context.params.id)); } else { context.response.status = 404; } }) .post(&quot;/todos&quot;, async (context: any) =&gt; { const body = context.request.body(); if (body.type === &quot;json&quot;) { const todo = await body.value; todos.set(Date.now(), todo); } context.response.body = { status: &quot;OK&quot; }; }); const { files } = await Deno.emit(&quot;./client.tsx&quot;, { bundle: &quot;module&quot; }); const clientJS = files[&quot;deno:///bundle.js&quot;] || &quot;&quot;; const serverrouter = new Router(); serverrouter.get(&quot;/static/client.js&quot;, (context: any) =&gt; { context.response.headers.set(&quot;Content-Type&quot;, &quot;text/html&quot;); context.response.body = clientJS; }); app.use(router.routes()); app.use(serverrouter.routes()); app.use(router.allowedMethods()); console.log(&quot;server is running on http://localhost:8000/&quot;); await app.listen({ port: 8000 }); function handlePage(ctx: any) { try { const body = ReactDOMServer.renderToString( &lt;App todos={[]} /&gt; // change here to pass todos as props ); ctx.response.body = `&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; window.__INITIAL_STATE__ = {&quot;todos&quot;: ${JSON.stringify( Array.from(todos.values()) )}}; &lt;/script&gt; &lt;/head&gt; &lt;body &gt; &lt;div id=&quot;root&quot;&gt;${body}&lt;/div&gt; &lt;script src=&quot;http://localhost:8000/static/client.js&quot; defer&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`; } catch (error) { console.error(error); } }   package.json { &quot;name&quot;: &quot;deno-react-ssr&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;deno run --allow-net --allow-read --unstable server.tsx -c tsconfig.json&quot;, &quot;start:clean&quot;: &quot;deno run --allow-net --allow-read --unstable --reload server.tsx -c tsconfig.json&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; }   Now you have a running, working SSR/Isomorphic App that is fully written in Deno. We didn‚Äôt use any nodejs/npm modules or WebPack.  Thanks for reading this tutorial. Please follow me to support me. For more of my work, check-out my website https://decipher.dev/.  You can find all the code in examples/ssr folder on my Github repo.  ","version":"Next","tagName":"h3"},{"title":"Final Domo‚Äã","type":1,"pageTitle":"Build an Isomorphic Application using Deno and React without WebPack","url":"/deno-by-example/advanced-react-ssr#final-domo","content":"   Hope you like this tutorial, Please follow me and clap for me on medium: isomorphic-application ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}