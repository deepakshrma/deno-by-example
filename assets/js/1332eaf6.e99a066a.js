"use strict";(self.webpackChunkdeno_by_example_next=self.webpackChunkdeno_by_example_next||[]).push([[590],{4084:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>o});var i=a(7624),r=a(2172);const t={id:"advanced-readline",title:"Read Line by Line as Data Stream",sidebar_label:"Read Line by Line",description:"How to read the entire file line by line in deno stream",keywords:["advanced","stream","data","file","network"],image:"https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/static/img/data_flow.png"},l=void 0,s={id:"advanced-readline",title:"Read Line by Line as Data Stream",description:"How to read the entire file line by line in deno stream",source:"@site/docs/advance_readline.md",sourceDirName:".",slug:"/advanced-readline",permalink:"/deno-by-example/advanced-readline",draft:!1,unlisted:!1,editUrl:"https://github.com/deepakshrma/deno-by-example/edit/master/docs/advance_readline.md",tags:[],version:"current",frontMatter:{id:"advanced-readline",title:"Read Line by Line as Data Stream",sidebar_label:"Read Line by Line",description:"How to read the entire file line by line in deno stream",keywords:["advanced","stream","data","file","network"],image:"https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/static/img/data_flow.png"},sidebar:"someSidebar",previous:{title:"Implementing JQ",permalink:"/deno-by-example/advanced-jq"},next:{title:"Implementing Logger",permalink:"/deno-by-example/advanced-logger"}},d={},o=[{value:"Read Id[rid]",id:"read-idrid",level:2},{value:"Sample: open file",id:"sample-open-file",level:3},{value:"Example: 1",id:"example-1",level:3},{value:"Example: 2",id:"example-2",level:3},{value:"Example: 3",id:"example-3",level:3},{value:"[Breakdown]",id:"breakdown",level:4},{value:"[_append]",id:"_append",level:4},{value:"Basic sample for Async Iterator",id:"basic-sample-for-async-iterator",level:3},{value:"[Breakdown]",id:"breakdown-1",level:4},{value:"Example: Final code",id:"example-final-code",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,r.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Deno"})," provides multiple APIs to read files. You can read the entire file using ",(0,i.jsx)(n.code,{children:"Deno.readAll"})," and ",(0,i.jsx)(n.code,{children:"Deno.readTextFile"}),". However, reading line by line is still not available in std library. Here in this tutorial, I will explain, How you can read the entire file line by line(Stream)."]}),"\n",(0,i.jsx)("img",{src:"https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/static/img/data_flow.png",width:"800",height:"400"}),"\n",(0,i.jsx)(n.p,{children:"Before going to actual code, Let's understand the standard library first with examples."}),"\n",(0,i.jsx)(n.h2,{id:"read-idrid",children:"Read Id[rid]"}),"\n",(0,i.jsxs)(n.p,{children:["Deno provides ",(0,i.jsx)(n.code,{children:"Deno.open"})," API to open a file. This is the async API. Meaning, you need to ",(0,i.jsx)(n.code,{children:"await"}),". In return you will get ",(0,i.jsx)(n.code,{children:"File"})," which contains ",(0,i.jsx)(n.code,{children:"rid"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"sample-open-file",children:"Sample: open file"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// examples/06_readfile_chunk.ts\nasync function main(name?: string) {\n  if (name) {\n    const file = await Deno.open(name);\n    console.log(file);\n  }\n}\nconst [fileName] = Deno.args;\nmain(fileName);\n"})}),"\n",(0,i.jsx)(n.p,{children:"[Run]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json\n\n## Output:\n# File { rid: 3 }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can see ",(0,i.jsx)(n.code,{children:"rid"})," in return. Let's use this ",(0,i.jsx)(n.code,{children:"rid"})," to get the chunk of data. Reading chunk requires API ",(0,i.jsx)(n.code,{children:"Deno.read"})]}),"\n",(0,i.jsx)(n.h3,{id:"example-1",children:"Example: 1"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// examples/06_readfile_chunk.ts\nasync function main(name?: string) {\n  if (name) {\n    const file = await Deno.open(name);\n    const decoder = new TextDecoder();\n    let buf = new Uint8Array(100);\n    const numOfByteRead = await Deno.read(file?.rid, buf);\n    console.log(numOfByteRead);\n    console.log(decoder.decode(buf));\n  }\n}\nconst [fileName] = Deno.args;\nmain(fileName);\n"})}),"\n",(0,i.jsx)(n.p,{children:"[Run]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json\n\n# Output\n# 100\n# {\n#   "id": 1,\n#   "version": "1.0.1",\n#   "contributors": [\n#     "deepak",\n#     "gary"\n#   ],\n#   "actor": {\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Here, as you can see, Every time you call ",(0,i.jsx)(n.code,{children:"Deno.read"})," it returns the number of bytes that have been read. If ",(0,i.jsx)(n.code,{children:"numOfByteRead"})," is ",(0,i.jsx)(n.code,{children:"null"})," meaning it is end of file[EOF]."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"new Uint8Array(100);"})," is Uint8Array to be filled while calling read. The buffer size could be anything. The reader will read bytes until buffer size."]}),"\n",(0,i.jsx)(n.p,{children:"If you notice, the read file is not a complete file. You need to increase the buff size to read all files."}),"\n",(0,i.jsx)(n.h3,{id:"example-2",children:"Example: 2"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// examples/06_readfile_chunk.ts\nasync function main(name?: string) {\n  if (name) {\n    const file = await Deno.open(name);\n    const decoder = new TextDecoder();\n    let buf = new Uint8Array(1000); // 353\n    const numOfByteRead = await Deno.read(file?.rid, buf);\n    console.log(numOfByteRead);\n    console.log(decoder.decode(buf));\n  }\n}\nconst [fileName] = Deno.args;\nmain(fileName);\n"})}),"\n",(0,i.jsx)(n.p,{children:"[Run]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json\n\n# Output\n# 353\n## JSON here..\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here in this example, I have increased buffer size to 1000, which is more than 353. So I can read the entire JSON file."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"[NOTE]:"})," You should avoid large buffer sizes. Reading a big file can create memory issues. and at the same time it will be hard to predict actual size."]}),"\n",(0,i.jsxs)(n.p,{children:["To read the entire file chunk by chunk, we can use recursion on ",(0,i.jsx)(n.code,{children:"then"}),"able API."]}),"\n",(0,i.jsx)(n.h3,{id:"example-3",children:"Example: 3"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// examples/06_readfile_chunk.ts\nasync function main(name?: string) {\n  if (name) {\n    const file = await Deno.open(name);\n    const decoder = new TextDecoder();\n    let buf = new Uint8Array(100);\n    let chunk = new Uint8Array(0);\n    Deno.read(file?.rid, buf).then(function readByte(numOfByteRead) {\n      if (numOfByteRead) {\n        chunk = _append(chunk, buf, numOfByteRead);\n        Deno.read(file?.rid, buf).then(readByte);\n      } else {\n        console.log(decoder.decode(chunk));\n      }\n    });\n  }\n}\nconst [fileName] = Deno.args;\nmain(fileName);\n"})}),"\n",(0,i.jsx)(n.p,{children:"[Run]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json\n\n# Output\n{\n  "id": 1,\n  "version": "1.0.1",\n  "contributors": [\n    "deepak",\n    "gary"\n  ],\n  "actor": {\n    "name": "Tom Cruise",\n    "age": 56,\n    "Born At": "Syracuse, NY",\n    "Birthdate": "July 3 1962",\n    "movies": [\n      "Top Gun",\n      "Mission: Impossible",\n      "Oblivion"\n    ],\n    "photo": "https://jsonformatter.org/img/tom-cruise.jpg"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"breakdown",children:"[Breakdown]"}),"\n",(0,i.jsxs)(n.p,{children:["Here in this code, when I call ",(0,i.jsx)(n.code,{children:"Deno.read(file?.rid, buf).then"}),". It will trigger a named function ",(0,i.jsx)(n.code,{children:"function readByte(numOfByteRead)"}),". This will internally check for ",(0,i.jsx)(n.code,{children:"numOfByteRead"})," each time. You can either append text return after decode by ",(0,i.jsx)(n.code,{children:"decoder.decode"}),". I am appending as Uint8Array. To appened Uint8Array arrays, I found a good sample on ",(0,i.jsx)(n.code,{children:"StackOverflow"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"_append",children:"[_append]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function _append(a: Uint8Array, b: Uint8Array, numOfByteRead: number) {\n  var c = new Uint8Array(a.length + numOfByteRead);\n  c.set(a, 0);\n  c.set(b.slice(0, numOfByteRead), a.length);\n  return c;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"[NOTE]:"})," If you don't pass ",(0,i.jsx)(n.code,{children:"numOfByteRead"}),", you may garbage value read for last time."]}),"\n",(0,i.jsx)(n.p,{children:"Nice \ud83d\ude42, all looks fine. However, still we are away from reading line by line. For that we will use an async iterator."}),"\n",(0,i.jsx)(n.h3,{id:"basic-sample-for-async-iterator",children:"Basic sample for Async Iterator"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"let range = {\n  from: 1,\n  to: 5,\n  [Symbol.asyncIterator]() {\n    return {\n      current: this.from,\n      last: this.to,\n      async next() {\n        const value = await new Promise<number>((resolve) =>\n          setTimeout(() => {\n            resolve(this.current++);\n          }, 1000)\n        );\n        if (value <= this.last) {\n          return { done: false, value };\n        } else {\n          return { done: true };\n        }\n      },\n    };\n  },\n};\n(async () => {\n  for await (let value of range) {\n    console.log(value); // 1,2,3,4,5\n  }\n})();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Just like ",(0,i.jsx)(n.code,{children:"Symbol.iterator"}),", we can use ",(0,i.jsx)(n.code,{children:"Symbol.asyncIterator"})," to create an async Iterator. Since typescript supports async iterator out of the box. We can use this API. To understand more, you can read ",(0,i.jsx)(n.a,{href:"https://javascript.info/async-iterators-generators",children:"async-iterators-generators"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To read line by line, I have created two utility methods ",(0,i.jsx)(n.code,{children:"_readTillDone"})," and ",(0,i.jsx)(n.code,{children:"readLine"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const _readTillDone = async (\n  rid: number,\n  text: string = ""\n): Promise<[string, string, boolean]> => {\n  let buf = new Uint8Array(100);\n  let indexOfLine = text.indexOf("\\n");\n  if (indexOfLine === -1) {\n    const num = await Deno.read(rid, buf);\n    if (num) {\n      text = text + decoder.decode(buf.slice(0, num));\n      return _readTillDone(rid, text);\n    } else {\n      return [text, "", true];\n    }\n  } else {\n    return [text.slice(0, indexOfLine), text.slice(indexOfLine + 1), false];\n  }\n};\n\nconst readLine = async (fileName: string) => {\n  const file = await Deno.open(fileName);\n  let text = "";\n  let done = false;\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        async next() {\n          const [t, rest, d] = await _readTillDone(file?.rid, text);\n          if (done) {\n            return { done: true, value: t };\n          } else {\n            text = rest;\n            done = d;\n            return { done: false, value: t };\n          }\n        },\n      };\n    },\n  };\n};\n'})}),"\n",(0,i.jsx)(n.h4,{id:"breakdown-1",children:"[Breakdown]"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"readLine"})," is very simple. On each async iterator call it will call ",(0,i.jsx)(n.code,{children:"_readTillDone"})," and return the line. However, _readTillDone is a little complex. I am using ",(0,i.jsx)(n.code,{children:"file.rid"})," to keep track of the file read."]}),"\n",(0,i.jsxs)(n.p,{children:["Whenever i call ",(0,i.jsx)(n.code,{children:"_readTillDone"})," with ",(0,i.jsx)(n.code,{children:"file?.rid, text"}),". It tries to split text with ",(0,i.jsx)(n.code,{children:"newLine"}),". I could not be able to find newLine. It tries to read more lines till the end. ",(0,i.jsx)(n.code,{children:"_readTillDone"})," returns three parameters ",(0,i.jsx)(n.code,{children:"[t, rest, d]"}),". Here ",(0,i.jsx)(n.code,{children:"t"}),", text read by line,",(0,i.jsx)(n.code,{children:"rest"})," is as buffer text and ",(0,i.jsx)(n.code,{children:"d"})," return as done."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"Let's complete the tutorial.\nOnce we have these utils, the implementation is very simple."})})}),"\n",(0,i.jsx)(n.h3,{id:"example-final-code",children:"Example: Final code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// examples/06_readfile_chunk.ts\nimport { readLine } from "https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/examples/file_reader.ts";\n\nasync function main(name?: string) {\n  if (name) {\n    // Example 6\n    const reader = await readLine(name);\n    for await (let value of reader) {\n      console.log(value);\n    }\n  }\n}\nconst [fileName] = Deno.args;\nmain(fileName);\n'})}),"\n",(0,i.jsx)(n.p,{children:"[Run]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json\n\n# Output\n{\n  "id": 1,\n  "version": "1.0.1",\n  "contributors": [\n    "deepak",\n    "gary"\n  ],\n  "actor": {\n    "name": "Tom Cruise",\n    "age": 56,\n    "Born At": "Syracuse, NY",\n    "Birthdate": "July 3 1962",\n    "movies": [\n      "Top Gun",\n      "Mission: Impossible",\n      "Oblivion"\n    ],\n    "photo": "https://jsonformatter.org/img/tom-cruise.jpg"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"TaDa! \ud83d\udc4f\ud83d\udc4f Now you can read the entire file line by line."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["I hope you like this tutorial. let me know your feedback in the comment. Please support(\ud83d\ude4f\ud83d\ude4f) by subscribing and clapping on ",(0,i.jsx)(n.a,{href:"https://deepak-v.medium.com/",children:"https://deepak-v.medium.com/"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["All working examples can be found in my Github: ",(0,i.jsx)(n.a,{href:"https://github.com/deepakshrma/deno-by-example/tree/master/examples",children:"https://github.com/deepakshrma/deno-by-example/tree/master/examples"})]}),"\n",(0,i.jsx)(n.admonition,{title:"Update:",type:"info",children:(0,i.jsxs)(n.p,{children:["Recently, i got to know. That Deno does has ",(0,i.jsx)(n.code,{children:"readlines"})," method to read reader line by line. It just documentation was missing. So i added document in Deno project. You can read it now here. ",(0,i.jsx)(n.a,{href:"https://deno.land/std/io",children:"https://deno.land/std/io"})]})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Sample:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { readLines } from "https://deno.land/std/io/mod.ts";\nimport * as path from "https://deno.land/std/path/mod.ts";\n\nconst filename = path.join(Deno.cwd(), "std/io/README.md");\nlet fileReader = await Deno.open(filename);\n\nfor await (let line of readLines(fileReader)) {\n  console.log(line);\n}```\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},2172:(e,n,a)=>{a.d(n,{I:()=>s,M:()=>l});var i=a(1504);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);